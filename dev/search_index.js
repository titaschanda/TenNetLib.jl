var documenterSearchIndex = {"docs":
[{"location":"ttn/example_optimize/#Example:-Optimizing-TTN","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"","category":"section"},{"location":"ttn/example_optimize/#Ground-state-search","page":"Example: Optimizing TTN","title":"Ground state search","text":"","category":"section"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"A straight-forward TTN optimization can be performed as follows.","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"using ITensors\nusing ITensorMPS\nusing TenNetLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpStrings()\n    \n    for j=1:N-1\n        os += 1, \"Sz\" => j, \"Sz\" => j+1\n        os += 0.5, \"S+\" => j, \"S-\" => j+1\n        os += 0.5, \"S-\" => j, \"S+\" => j+1\n    end\n    \n    H = CouplingModel(os,sites)\n\n    psi0 = default_randomTTN(sites, 12, QN(\"Sz\", 0))\n    sweeppath = default_sweeppath(psi0)\n\n    params = OptimizeParamsTTN(; nsweeps = [10, 10], maxdim = [20, 50],\n                               cutoff = 1e-14, noise = 1e-3, noisedecay = 2,\n                               disable_noise_after = 5)\n\n    en, psi = optimize(psi0, H, params, sweeppath)\nend","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"warning: Warning\nFor TTN optimzaion, direct MPO input is not supported. One can, however, prepare a CouplingModel from MPO using CouplingModel(mpos::MPO...). ","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"Instead of using such higher-level code, one can also use lower-level functions for a better control.","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"sysenv = StateEnvsTTN(psi0, H)\n\nswdata = optimize!(sysenv, params, sweeppath)\n\n# Get energy from `Sweepdata`\nenergy = swdata.energy[end]\n\n# take a shallow copy of the TTN\n# if the `StateEnvsTTN` will be updated later again\npsi = getpsi(sysenv)\n\n# Alternatively, take the psi from `StateEnvsTTN` itself.\n# NOTE: This can crash the simulation, if the TTN is modified (e.g., in measurements)\n# and `StateEnvsTTN` is going to be updated later on.\n# psi = sysenv.psi","category":"page"},{"location":"ttn/example_optimize/#Excited-state-search","page":"Example: Optimizing TTN","title":"Excited state search","text":"","category":"section"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"Excited state search is also straightforword.","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"# Given a ground state `psi_gr`, initial TTN `psi0`,\n# and a Hamiltonian `H`\n\nen, psi = optimize(psi0, H, [psi_gr], params, sweeppath; weight = 10.0)","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"Similarly, using StateEnvsTTN:","category":"page"},{"location":"ttn/example_optimize/","page":"Example: Optimizing TTN","title":"Example: Optimizing TTN","text":"sysenv_ex = StateEnvsTTN(psi0, H, [psi_gr]; weight = 10.0)\nswdata_ex = optimize!(sysenv_ex, params, sweeppath)\n\n# Get energy from `Sweepdata`\nenergy1 = swdata_ex.energy[end]\n\n# take a shallow copy of the TTN\n# if the `StateEnvsTTN` will be updated later again\npsi1 = getpsi(sysenv_ex)\n\n# Alternatively, take the psi from `StateEnvsTTN` itself.\n# NOTE: This can crash the simulation, if the TTN is modified (e.g., in measurements)\n# and `StateEnvsTTN` is going to be updated later.\n# psi1 = sysenv_ex.psi","category":"page"},{"location":"base/misc/#Miscellaneous-typedefs-and-functions","page":"Miscellaneous typedefs and functions","title":"Miscellaneous typedefs and functions","text":"","category":"section"},{"location":"base/misc/#TenNetLib.Vector2","page":"Miscellaneous typedefs and functions","title":"TenNetLib.Vector2","text":"const Vector2{T} = Vector{Vector{T}}\n\nVector of Vectors.\n\n\n\n\n\n","category":"type"},{"location":"base/misc/#TenNetLib.IDType","page":"Miscellaneous typedefs and functions","title":"TenNetLib.IDType","text":"const IDType = ITensors.IDType\n\nType of randomly generated id. It is usually UInt64.\n\n\n\n\n\n","category":"type"},{"location":"base/misc/#TenNetLib.IDTensors","page":"Miscellaneous typedefs and functions","title":"TenNetLib.IDTensors","text":"const IDTensors = Dict{IDType, ITensor}\n\nDictionary of key = randomly generated id and value = ITensor objects.\n\n\n\n\n\n","category":"type"},{"location":"base/misc/#TenNetLib.gen_rand_id","page":"Miscellaneous typedefs and functions","title":"TenNetLib.gen_rand_id","text":"function gen_rand_id()\n\nusing Base: diffnames using Base: diffnames\n\nGenerates a random id.\n\n\n\n\n\n","category":"function"},{"location":"base/misc/#TenNetLib.combineinds-Tuple{Vector{Index{Int64}}}","page":"Miscellaneous typedefs and functions","title":"TenNetLib.combineinds","text":"function combineinds(inds::Vector{Index};\n                     maxdim::Union{Nothing, Int} = nothing, \n                     maxqnblocks::Union{Nothing, Int} = nothing,\n                     kwargs...)\n\nCombine a vector of Index into one (like ITensors.jl's combiner). maxdim is be the maximum dimension of the output Index, maxqnblocks represents maximum number of QN blocks to retain in the output Index.\n\n\n\n\n\n","category":"method"},{"location":"base/misc/#TenNetLib.indexintersection-Tuple{Vector{Index{Int64}}, Vector{Index{Int64}}}","page":"Miscellaneous typedefs and functions","title":"TenNetLib.indexintersection","text":"function indexintersection(inds1::Vector{Index}, inds2::Vector{Index};\n                           maxdim::Union{Nothing, Int} = nothing,\n                           maxqnblocks::Union{Nothing, Int} = nothing,\n                           kwargs...)\n\nPerforms set intersection of two vectors of Index. maxdim is be the maximum dimension of the output Index, maxqnblocks represents maximum number of QN blocks to retain in the output Index.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#StateEnvs:-A-container-to-store-the-MPS-and-its-environments","page":"StateEnvs","title":"StateEnvs: A container to store the MPS and its environments","text":"","category":"section"},{"location":"mps/state_envs/","page":"StateEnvs","title":"StateEnvs","text":"At the lowest-level of abstraction, TenNetLib.jl defines StateEnvs to hold an MPS and its environments to be modified in place.","category":"page"},{"location":"mps/state_envs/","page":"StateEnvs","title":"StateEnvs","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/state_envs/#TenNetLib.StateEnvs","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"mutable struct StateEnvs{T <: Union{ProjMPO,\n                              ProjMPO_MPS2,\n                              ProjMPOSum2,\n                              ProjMPOSum_MPS,\n                              ProjCouplingModel,\n                              ProjCouplingModel_MPS}\n                        }\n    psi::MPS\n    PH::T\nend\n\nHolds the MPS state psi and its environments PH.\n\n\n\n\n\n","category":"type"},{"location":"mps/state_envs/#TenNetLib.getpsi-Tuple{StateEnvs}","page":"StateEnvs","title":"TenNetLib.getpsi","text":"function getpsi(sysenv::StateEnvs)\n\nReturns (shallow copy of) the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.getenv-Tuple{StateEnvs}","page":"StateEnvs","title":"TenNetLib.getenv","text":"function getenv(sysenv::StateEnvs)\n\nReturns (shallow copy of) the environment PH.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.StateEnvs-Tuple{MPS, MPO}","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::MPO)\n\nConstructor of the StateEnvs from a single MPO.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.StateEnvs-Tuple{MPS, Vector{MPO}}","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"function StateEnvs(psi::MPS, Hs::Vector{MPO})\n\nConstructor of the  StateEnvs from a vector of MPO. Environments are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.StateEnvs-Tuple{MPS, MPO, Vector{MPS}}","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::MPO, Ms::Vector{MPS}; weight::Float64)\n\nConstructor of the StateEnvs from a single MPO and a vector of MPS used for excited state DMRG.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.StateEnvs-Tuple{MPS, Vector{MPO}, Vector{MPS}}","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"function StateEnvs(psi::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}; weight::Float64)\n\nConstructor of the StateEnvs from a vector of MPO and a vector of MPS used for excited state DMRG. Environments for MPOs are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.StateEnvs-Tuple{MPS, CouplingModel}","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::CouplingModel)\n\nConstructor of the StateEnvs from a CouplingModel. Each terms in the CouplingModel are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.StateEnvs-Tuple{MPS, CouplingModel, Vector{MPS}}","page":"StateEnvs","title":"TenNetLib.StateEnvs","text":"function StateEnvs(psi::MPS, H::CouplingModel, Ms::Vector{MPS}; weight::Float64)\n\nConstructor of StateEnvs from a CouplingModel and a vector of MPS used for excited state DMRG. Each terms in the CouplingModel are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.updateH!-Tuple{StateEnvs{ProjMPO}, MPO}","page":"StateEnvs","title":"TenNetLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPO}, H::MPO; recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. If recalcEnv = false, it reuses previous environments.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.updateH!-Tuple{StateEnvs{ProjMPOSum2}, Vector{MPO}}","page":"StateEnvs","title":"TenNetLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPOSum2}, Hs::Vector{MPO}; recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.updateH!-Tuple{StateEnvs{ProjMPO_MPS2}, MPO, Vector{MPS}}","page":"StateEnvs","title":"TenNetLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPO_MPS2}, H::MPO, Ms::Vector{MPS};\n                  weight::Float64, recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\nweight::Union{Nothing, Float64} = nothing.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.updateH!-Tuple{StateEnvs{ProjMPOSum_MPS}, Vector{MPO}, Vector{MPS}}","page":"StateEnvs","title":"TenNetLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjMPOSum_MPS}, Hs::Vector{MPO}, Ms::Vector{MPS};\n                  weight::Float64, recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\nweight::Union{Nothing, Float64} = nothing.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.updateH!-Tuple{StateEnvs{ProjCouplingModel_MPS}, CouplingModel, Vector{MPS}}","page":"StateEnvs","title":"TenNetLib.updateH!","text":"function updateH!(sysenv::StateEnvs{ProjCouplingModel_MPS}, H::CouplingModel, Ms::Vector{MPS};\n                  weight::Float64, recalcEnv::Bool = true)\n\nUpdate Hamiltonian H in sysenv::StateEnvs. recalcEnv = false is not supported.\n\nweight::Union{Nothing, Float64} = nothing.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#ITensorMPS.nsite-Tuple{StateEnvs}","page":"StateEnvs","title":"ITensorMPS.nsite","text":"function nsite(sysenv::StateEnvs)\n\nReturns the nsite of the environment. nsite = 1 for single-site environment, nsite = 2 for two-site environmrnt, and so on.  Currently, only uses nsite = 0, 1, or 2.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#ITensorMPS.set_nsite!-Tuple{StateEnvs, Int64}","page":"StateEnvs","title":"ITensorMPS.set_nsite!","text":"function set_nsite!(sysenv::StateEnvs, nsite::Int)\n\nSet nsite of the environment. nsite = 1 for single-site environment, nsite = 2 for two-site environmrnt, and so on.  Currently, only uses nsite = 0, 1, or 2.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#ITensorMPS.position!-Tuple{StateEnvs, Int64}","page":"StateEnvs","title":"ITensorMPS.position!","text":"function position!(sysenv::StateEnvs, pos::Int)\n\nCompute the left and right environments at position pos.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#TenNetLib.product-Tuple{StateEnvs, ITensor}","page":"StateEnvs","title":"TenNetLib.product","text":"function product(sysenv::StateEnvs, v::ITensor)\n\nReturns the Matrix-Vector product between the environment and input ITensor v.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#Base.copy-Tuple{StateEnvs}","page":"StateEnvs","title":"Base.copy","text":"function Base.copy(sysenv::StateEnvs)\n\nShallow copy of StateEnvs.\n\n\n\n\n\n","category":"method"},{"location":"mps/state_envs/#Base.length-Tuple{StateEnvs}","page":"StateEnvs","title":"Base.length","text":"function Base.length(sysenv::StateEnvs)\n\nReturns the length of the underlying MPS/Environment.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg/#Performing-DMRG","page":"Performing DMRG","title":"Performing DMRG","text":"","category":"section"},{"location":"mps/dmrg/","page":"Performing DMRG","title":"Performing DMRG","text":"Functions to perfom (and control) DMRG runs.","category":"page"},{"location":"mps/dmrg/#DMRGParams","page":"Performing DMRG","title":"DMRGParams","text":"","category":"section"},{"location":"mps/dmrg/","page":"Performing DMRG","title":"Performing DMRG","text":"TenNetLib.jl defines a struct, called  DMRGParams, to control DMRG simulations.","category":"page"},{"location":"mps/dmrg/#TenNetLib.DMRGParams","page":"Performing DMRG","title":"TenNetLib.DMRGParams","text":"mutable struct DMRGParams\n    maxdim::Vector{Int}\n    nsweeps::Vector{Int}\n    cutoff::Vector{Float64}\n    noise::Vector{Float64}\n    noisedecay::Vector{Float64}\n    disable_noise_after::Vector{Int}\nend\n\nHolds parameters to control DMRG sweeps.\n\nmaxdim::Vector{Int}: Maximum allowed MPS bond/link dimensions at each stages of DMRG.\nnsweeps::Vector{Int}: Number of sweeps to be performed at each statges of DMRG.\ncutoff::Vector{Float64}: Cutoff for SVD truncation at each stages of DMRG.\nnoise::Vector{Float64}: Noise level at each stages of DMRG.\nnoisedecay::Vector{Float64}: Decay of noise level at each states of DMRG. Noise is divided by noisedecay after each sweep.\ndisable_noise_after::Vector{Int}: Switch of noise after this many sweeps at each\n\nstates of DMRG.\n\nAll these Vectors must have same dimension.\n\n\n\n\n\n","category":"type"},{"location":"mps/dmrg/#TenNetLib.DMRGParams-Tuple{}","page":"Performing DMRG","title":"TenNetLib.DMRGParams","text":"function DMRGParams(;maxdim::Vector{Int}, nsweeps::Vector{Int}, \n                    cutoff::Union{Vector{Float64}, Float64, Int} = _Float64_Threshold,\n                    noise::Union{Vector{Float64}, Float64, Int} = 0.0,\n                    noisedecay::Union{Vector{Float64}, Float64, Int} = 1.0,\n                    disable_noise_after::Union{Vector{Int}, Int} = typemax(Int))\n\nConstructor for DMRGParams. Takes only named arguments.\n\nmaxdim::Vector{Int}: Maximum allowed MPS bond/link dimensions at each stages of DMRG.\nnsweeps::Vector{Int}: Number of sweeps to be performed at each statges of DMRG.\ncutoff::Union{Int, Float64, Vector{Float64}} = Float64_threshold(): Cutoff for SVD truncation at each stages of DMRG. If Float64, cutoff remains same throughout the DMRG simulation. \nnoise::Union{Float64, Int, Vector{Float64}} = 0.0: Noise level at each stages of DMRG. If Float64 or Int, initial noise remains same throughout the DMRG simulation.\nnoisedecay::Union{Float64, Int, Vector{Float64}} = 1.0: Decay of noise level at each states of DMRG. Noise is divided by noisedecay after each sweep. If Float64 or Int, noisedecay remains same throughout the DMRG simulation.\ndisable_noise_after::Union{Int, Vector{Int}} = typemax(Int): Switch of noise after this many sweeps at each states of DMRG. If Int, disable_noise_after remains same throughout the DMRG simulation.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg/#Base.copy-Tuple{DMRGParams}","page":"Performing DMRG","title":"Base.copy","text":"Base.copy(params::DMRGParams)\n\nShallow copy DMRGParams.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg/#A-lower-level-DMRG-function","page":"Performing DMRG","title":"A lower level DMRG function","text":"","category":"section"},{"location":"mps/dmrg/","page":"Performing DMRG","title":"Performing DMRG","text":"Following function modifies StateEnvs in-place. Skip this function if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/dmrg/#TenNetLib.dmrg!-Tuple{StateEnvs, DMRGParams, Int64}","page":"Performing DMRG","title":"TenNetLib.dmrg!","text":"function dmrg!(sysenv::StateEnvs, params::DMRGParams, nsite::Int; kwargs...)\n\nPerforms DMRG.\n\nArguments:\n\nsysenv::StateEnvs.\nparams::DMRGParams.\nnsite::Int of the environment. Either 1 or 2 for one-site or two-site update respectively.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state DMRG. Must be set to greater than 0 for the excited state DMRG.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: DMRG (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\nentropyErrGoal: DMRG (at a particluar stage) stops when mid-chain entropy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nWhen both energyErrGoal and entropyErrGoal are given, both conditions must be satisfied to trigger this early stopping.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0.: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\nSweepData\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg/#Higher-level-DMRG-functions","page":"Performing DMRG","title":"Higher level DMRG functions","text":"","category":"section"},{"location":"mps/dmrg/","page":"Performing DMRG","title":"Performing DMRG","text":"Standard two- and single-site DMRG functions. Single-site DMRG can increase the bond-dimension if noise > Float64_threshold().","category":"page"},{"location":"mps/dmrg/#TenNetLib.dmrg2-Union{Tuple{T}, Tuple{MPS, T, DMRGParams}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing DMRG","title":"TenNetLib.dmrg2","text":"function dmrg2(psi0::MPS, H::MPO, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::CouplingModel, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, Hs::Vector{MPO}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::MPO, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg2(psi0::MPS, H::CouplingModel, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\n\nPerforms two-site DMRG.\n\nArguments:\n\npsi0::MPS: Initial MPS.\nH::MPO, H::CouplingModel, Hs::Vector{MPO}, Ms::Vector{MPS}.\nparams::DMRGParams.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state DMRG. Must be set to greater than 0 for the excited state DMRG.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: DMRG (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\nentropyErrGoal: DMRG (at a particluar stage) stops when mid-chain entropy difference between two consecutive sweeps falls below this threshold and DMRG moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nWhen both energyErrGoal and entropyErrGoal are given, both conditions must be satisfied to trigger this early stopping.\n\nNamed arguments for eig_solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Energy.\n::MPS: The state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/dmrg/#TenNetLib.dmrg1-Union{Tuple{T}, Tuple{MPS, T, DMRGParams}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing DMRG","title":"TenNetLib.dmrg1","text":"function dmrg1(psi0::MPS, H::MPO, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::CouplingModel, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, Hs::Vector{MPO}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::MPO, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, Hs::Vector{MPO}, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\nfunction dmrg1(psi0::MPS, H::CouplingModel, Ms::Vector{MPS}, params::DMRGParams; kwargs...)\n\nPerforms single-site DMRG. All other details are same as in dmrg2.\n\n\n\n\n\n","category":"method"},{"location":"mps/example_tdvp/#Example:-TDVP","page":"Example: TDVP","title":"Example: TDVP","text":"","category":"section"},{"location":"mps/example_tdvp/#Time-evolution-with-time-dependent-variational-principle-(TDVP).","page":"Example: TDVP","title":"Time-evolution with time dependent variational principle (TDVP).","text":"","category":"section"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"A straight-forward TDVP (with dynamical sweeps) can be performed as follows. Note that TDVP computes ψ' = exp(time_step * H) * ψ. Therefore, for real-time dynamics with step dt, time_step should be -im * dt.","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"using ITensors\nusing ITensorMPS\nusing TenNetLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpSum()\n    \n    for j=1:N-1\n        os += 1, \"Sz\", j, \"Sz\", j+1\n        os += 0.5, \"S+\", j, \"S-\", j+1\n        os += 0.5, \"S-\", j, \"S+\", j+1\n    end\n    \n    H = MPO(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    tau = -0.01im    \n    engine = TDVPEngine(psi0, H)\n    for ii = 1:100\n\n    \t# `nsite = \"dynamic\"` for dynamical selection between\n\t# single- and two-site variants at different bonds\n        tdvpsweep!(engine, tau,\n                   nsite = \"dynamic\";\n                   maxdim = 200,\n                   cutoff = 1E-12,\n                   extendat = 5)\n\n\t# Errors in the last sweep and the total error till this point\n\tswerr = sweeperror(engine)\n\ttotalerr = totalerror(engine)\n\t\n\tpsi = getpsi(engine)\n\t\n\t# DO STUFF\n    end\nend","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"Here, we have used OpSum and MPO. Alternatively, standard OpStrings and CouplingModel can be used.","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"Optionally, one can use pure single- or two-site updates. If the TDVPEngine is created with a single MPO then Global Subspace Expansion can be performed.","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"for ii = 1:100\n\n    # GSE at every 5th sweep.\n    if ii % 5 == 1\n        krylov_extend!(engine)\n    end\n    \n    # `nsite = 1` for single-site update\n    tdvpsweep!(engine, tau,\n               nsite = 1;\n               maxdim = 200,\n               cutoff = 1E-12)\n\n    # Errors in the last sweep and the total error till this point\n    swerr = sweeperror(engine)\n    totalerr = totalerror(engine)\n\t\n    psi = getpsi(engine)\n\t\n    # DO STUFF\nend","category":"page"},{"location":"mps/example_tdvp/#Time-evolution-with-time-dependent-Hamiltonian","page":"Example: TDVP","title":"Time-evolution with time-dependent Hamiltonian","text":"","category":"section"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"For time-dependent Hamiltonian, updateH! can be used.","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"using ITensors\nusing TenNetLib\n\nfunction makeHt(sites, t)\n\n    os = OpSum()    \n    for j=1:N-1\n        os += 1, \"Sz\", j, \"Sz\", j+1\n        os += 0.5, \"S+\", j, \"S-\", j+1\n        os += 0.5, \"S-\", j, \"S+\", j+1\n    end\n    for j=1:N\n        os += t, \"Sz\", j\n    end\n    return MPO(os,sites)\nend\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    dt = 0.01\n    tau = -im * dt\n\n    H0 = makeHt(sites, 0.0)\n    engine = TDVPEngine(psi0, H0)\n    \n    for ii = 1:100\n\n    \t# `nsite = \"dynamic\"` for dynamical selection between\n\t# single- and two-site variants at different bonds\n        tdvpsweep!(engine, tau,\n                   nsite = \"dynamic\";\n                   maxdim = 200,\n                   cutoff = 1E-12,\n                   extendat = 5)\n\n\t# Errors in the last sweep and the total error till this point\n\tswerr = sweeperror(engine)\n\ttotalerr = totalerror(engine)\n\t\n\tpsi = getpsi(engine)\n\t\n\t# DO STUFF\n\n\t# update Hamiltonian for the next iteration\n\tHt = makeHt(sites, ii*dt)\n\tupdateH!(engine, Ht)\n    end\nend","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"Note 1: The above example for time-dependent Hamiltonian is very crude. In real situations, the update in the Hamiltonian should be done with proper care.","category":"page"},{"location":"mps/example_tdvp/","page":"Example: TDVP","title":"Example: TDVP","text":"Note 2: When  the TDVPEngine is created from a single MPO and dt is small, one can use recalcEnv = false in updateH!, so that environments from the last step is reused.","category":"page"},{"location":"mps/measure/#Measuring-the-MPS","page":"Measuring the MPS","title":"Measuring the MPS","text":"","category":"section"},{"location":"mps/measure/#TenNetLib.entropy-Tuple{MPS, Int64}","page":"Measuring the MPS","title":"TenNetLib.entropy","text":"function entropy(psi::MPS, bond::Int)\n\nCompute von Neumann entropy of a given MPS psi at bond.\n\nNote: Since both ITensors.jl and ITensorMPS.jl export a function named entropy(), this function must be explicitly called as TenNetLib.entropy().\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.entropy-Tuple{MPS}","page":"Measuring the MPS","title":"TenNetLib.entropy","text":"function entropy(psi::MPS; bonds = nothing)\n\nCompute von Neumann entropies of a given MPS psi at all the bonds.\n\nOptionally, for specific bonds, keyword argument bonds can be specified, e.g., bonds = [1, 2, 3].\n\nNote: Since both ITensors.jl and ITensorMPS.jl export a function named entropy(), this function must be explicitly called as TenNetLib.entropy().\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.bond_spectrum-Tuple{MPS, Int64}","page":"Measuring the MPS","title":"TenNetLib.bond_spectrum","text":"bond_spectrum(psi::MPS, bond::Int; by_charge = false)\n\nCompute the eigenvalue spectrum  lambda_k  of the reduced density matrix obtained by cutting the MPS psi at the specified bond.\n\nIf by_charge == false, the function returns the full spectrum as a Vector{Float64}.\n\nIf by_charge == true, the spectrum is grouped into different QN sectors, and the result is returned as a Vector{Pair{QN, Vector{Float64}}}, where each pair contains a QN label and its associated eigenvalue spectrum.\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.bond_spectrum-Tuple{MPS}","page":"Measuring the MPS","title":"TenNetLib.bond_spectrum","text":"bond_spectrum(psi::MPS; bonds = nothing, by_charge = false)\n\nCompute the eigenvalue spectra  lambda_k  of the reduced density matricies obtained by cutting the MPS psi at all the bonds.\n\nOptionally, for specific bonds, keyword argument bonds can be specified, e.g., bonds = [1, 2, 3].\n\nReturns a vector of spectra, one for each bonds. The type depends on by_charge.\n\nIf by_charge == false, the function returns the full spectrum as a Vector{Vector{Float64}}.\n\nIf by_charge == true, the spectrum is grouped into different QN sectors, and the result is returned as a Vector{Vector{Pair{QN, Vector{Float64}}}}, where each pair contains a QN label and its associated eigenvalue spectrum.\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, MPS, ITensor}} where T<:Union{Float64, ComplexF64}","page":"Measuring the MPS","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::MPS, opten::ITensor)\n\nReturns (complex / real) local expectation value (::ComplexF64 / ::Float64) of a given MPS psi::MPS. The operator opten::ITensor must be single-site operator.\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, MPS, String, Int64}} where T<:Union{Float64, ComplexF64}","page":"Measuring the MPS","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::MPS, opstr::String, pos::Int)\n\nReturns (complex / real) local expectation value (::ComplexF64 / ::Float64) of a given MPS psi::MPS for a given operator name (opstr::String) and a site index (pos::Int) \n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, MPS, String}} where T<:Union{Float64, ComplexF64}","page":"Measuring the MPS","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::MPS, opstr::String; kwargs...)\n\nReturns (complex / real) local expectation values (::Vector{ComplexF64} / ::Vector{Float64}) of a given MPS psi::MPS for a given operator name (opstr::String) at all the sites.\n\nOptionally, for specific sites, keyword argument sites can be specified, e.g., sites = [1, 2, 3].\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, MPS, Vector{ITensor}}} where T<:Union{Float64, ComplexF64}","page":"Measuring the MPS","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::MPS, optens::Vector{ITensor})\n\nReturns (complex / real) multi-site expectation value (::ComplexF64 / ::Float64) of a given MPS psi::MPS for a given vector of single-site operators (optens::Vector{ITensor}).\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"mps/measure/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, MPS, Vector{Pair{String, Int64}}}} where T<:Union{Float64, ComplexF64}","page":"Measuring the MPS","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::MPS, oppairs::Vector{Pair{String, Int}};\n                 isfermions::Bool = true)\n\nReturns (complex / real) multi-site expectation value (::ComplexF64 / ::Float64) of a given MPS psi::MPS. oppairs::Vector{Pair{String, Int}} contains pairs of operator names (String) and site locations (Int). E.g., for <ψ|OᵢOⱼOₖ... |ψ>, oppairs = [\"O\" => i, \"O\" => j, \"O\" => k,...].\n\nFermionic JW strings are added automatically for fermionic operators if isfermions::Bool = true (default).\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\nExample:\n\nvalueC = measure(psi, [\"Cdag\" => 2, \"C\" => 6, \"Cdag\" => 9, \"C\" => 12])\nvalueR = measure(Float64, psi, [\"Cdag\" => 2, \"C\" => 6, \"Cdag\" => 9, \"C\" => 12])\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn/#Tree-Tensor-Networks-(TTN)","page":"Tree Tensor Networks","title":"Tree Tensor Networks (TTN)","text":"","category":"section"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"Tree Tensor Network (TTN) is a loop-free hierarchical tensor network (see belew).","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"Tree Tensor Network for a system of size 16\n(Image: Tree Tensor Network)","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"Due to enhanced connectivity in the structure of TTN, it can support long-range quantum correlations comapred to MPS. Moreover, simulations for systems with periodic boundary conditions (PBC) are almost as efficient as the same with open boundary conditions (OBC). TTNs have found their place for simulating 2D or pseudo-2D ladder/cylinder systems with PBC where the performance of MPS is not adequate.","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"TenNetLib.jl implements the unconstrained optimization for obtaining ground as well as excited states as described in Phys. Rev. B 90, 125154 (2014) and SciPost Phys. Lect. Notes 8 (2019).","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"Each tensor in the TTN are indexed by a pair (Tuple) of Ints = (ll, nn).","category":"page"},{"location":"ttn/ttn/#TenNetLib.Int2","page":"Tree Tensor Networks","title":"TenNetLib.Int2","text":"const Int2 = Tuple{Int, Int}\n\nTuple of two Ints. \n\n\n\n\n\n","category":"type"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"In the default scenario, ll denotes the layer index and nn denotes the tensor index at each layer (see the image above). The counting for ll, in the default case, starts at the bottom (towards to top level), while nn counts from left. The structure of the network is defined by a Graph{Int2} object. The link / bond between two neighboring nodes is denoted by a LinkTypeTTN object, an unordered pair of Int2s.","category":"page"},{"location":"ttn/ttn/#TenNetLib.LinkTypeTTN","page":"Tree Tensor Networks","title":"TenNetLib.LinkTypeTTN","text":"struct LinkTypeTTN\n    first::Int2\n    second::Int2\nend\n\nLink / bond between two nodes first and second.\n\n\n\n\n\n","category":"type"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"info: Info\nThe order of the nodes inside LinkTypeTTN is irrelevant, i.e., LinkTypeTTN(node1, node2) == LinkTypeTTN(node2, node1).","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"info: Info\nTenNetLib.jl can automatically handle system-sizes that are not powers of 2. No special care is needed for such system-sizes.","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"TTN for system-size 12 TTN for system-size 14\nSites 1, 4, 7, 11 are directly connected to ll=2 tensors Sites 5, 12 are directly connected to ll=2 tensors\nNodes (1,1), (1,3), (1,5), (1,7) are removed Nodes (1,3), (1,7) are removed\n(Image: TTN size 12) (Image: TTN size 14)","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"info: Info\nThe TTN codes defined in TenNetLib.jl can readily work, without any changes, for any loop-free tensor networks, e.g., Fork Tensor Networks.","category":"page"},{"location":"ttn/ttn/","page":"Tree Tensor Networks","title":"Tree Tensor Networks","text":"tip: Tip\nFor 2D systems, use a mapping from the 2D lattice to a 1D chain using Hilbert curve, as shown in Quantum 5, 556 (2021)","category":"page"},{"location":"base/graph/#The-Graph-object","page":"The Graph object","title":"The Graph object","text":"","category":"section"},{"location":"base/graph/","page":"The Graph object","title":"The Graph object","text":"TenNetLib.jl defines its own undirected graph object, the Graph. Currently only used for the Tree Tensor Network (TTN) codes.","category":"page"},{"location":"base/graph/#TenNetLib.Graph","page":"The Graph object","title":"TenNetLib.Graph","text":"mutable struct Graph{T}\n    nodes::Set{T}\n    edges::Dict{T, Set{T}}\nend\n\nUndirected graph where nodes are of type T.\n\nnodes::Set{T}: Holds the nodes of the graph.\nedges::Dict{T, Set{T}}: Holds the edges of the graph. For a given node as key,  holds all the connected nodes as value of the Dict.\n\n\n\n\n\n","category":"type"},{"location":"base/graph/#TenNetLib.Graph-Union{Tuple{}, Tuple{T}} where T","page":"The Graph object","title":"TenNetLib.Graph","text":"function Graph{T}()\n\nContructor of empty Graph.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.Graph-Union{Tuple{Set{T}}, Tuple{T}} where T","page":"The Graph object","title":"TenNetLib.Graph","text":"function Graph{T}(nodes::Set{T}) where T\nfunction Graph{T}(nodes::Vector{T}) where T\n\nConstructor of Graph with a list of nodes and empty edges.\n\nnodes: Intial nodes.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.getnodes-Union{Tuple{Graph{T}}, Tuple{T}} where T","page":"The Graph object","title":"TenNetLib.getnodes","text":"function getnodes(graph::Graph{T}) where T = copy(graph.nodes)\n\nReturns (shallow copy of) nodes in the Graph.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.hasnode-Union{Tuple{T}, Tuple{Graph{T}, T}} where T","page":"The Graph object","title":"TenNetLib.hasnode","text":"function hasnode(graph::Graph{T}, node::T) where T\n\nChecks whether a node is in the Graph.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.addnode!-Union{Tuple{T}, Tuple{Graph{T}, T}} where T","page":"The Graph object","title":"TenNetLib.addnode!","text":"function addnode!(graph::Graph{T}, node::T) where T\n\nAdds a node to the Graph.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.addedge!-Union{Tuple{T}, Tuple{Graph{T}, T, T}} where T","page":"The Graph object","title":"TenNetLib.addedge!","text":"function addedge!(graph::Graph{T}, node1::T, node2::T) where T\n\nAdds an edge between node1 and node2. If node1 or node2 are not present in the Graph, they are added.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.isneighbor-Union{Tuple{T}, Tuple{Graph{T}, T, T}} where T","page":"The Graph object","title":"TenNetLib.isneighbor","text":"function isneighbor(graph::Graph{T}, node1::T, node2::T)::Bool where T\n\nChecks whether node1 and node2 are connected by an edge.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.bfs-Union{Tuple{T}, Tuple{Graph{T}, T}, Tuple{Graph{T}, T, Union{Nothing, T}}} where T","page":"The Graph object","title":"TenNetLib.bfs","text":"function bfs(graph::Graph{T},\n             source::T,\n             destination::Union{Nothing, T} = nothing) where T\n\nPerforms a BFS starting from the node source (and optionally, to the destination).\n\nReturn values\n\n::Dict{T, Int}: Distances of nodes (key) in the BFS path.\n::Dict{T, T}: Parents of nodes (key) in the BFS path.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.nodes_from_bfs-Union{Tuple{T}, Tuple{Graph{T}, T}} where T","page":"The Graph object","title":"TenNetLib.nodes_from_bfs","text":"function nodes_from_bfs(graph::Graph{T}, source::T;\n                        reverse::Bool = false) where T\n\nfunction nodes_from_bfs(graph::Graph{T}, source::T,\n                        destinations::Union{Set{T}, Vector{T}};\n                        reverse::Bool = false) where T\n\nReturns the Vector of nodes in the BFS path from the source (optionally, towards the destinations). If reverse=true returns the reverse order of nodes.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.shortest_path-Union{Tuple{T}, Tuple{Graph{T}, T, T}} where T","page":"The Graph object","title":"TenNetLib.shortest_path","text":"function shortest_path(graph::Graph{T}, source::T, destination::T) where T\n\nReturns the shortest path between source and destination in a Graph.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.nextnode_in_path-Union{Tuple{T}, Tuple{Graph{T}, T, T}, Tuple{Graph{T}, T, T, Any}} where T","page":"The Graph object","title":"TenNetLib.nextnode_in_path","text":"function nextnode_in_path(graph::Graph{T}, source::T, destination::T, n=1) where T\n\nReturns the next node in the shortest path between source and destination in a Graph. Optionally, finds nth next-node in the path.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.has_cycle-Union{Tuple{Graph{T}}, Tuple{T}} where T","page":"The Graph object","title":"TenNetLib.has_cycle","text":"function has_cycle(graph::Graph{T}) where T\n\nChecks whether a Graph has cycles/loops in it.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.find_sum_central_node-Union{Tuple{Graph{T}}, Tuple{T}, Tuple{Graph{T}, Union{Nothing, Set{T}}}} where T","page":"The Graph object","title":"TenNetLib.find_sum_central_node","text":"function find_sum_central_node(graph::Graph{T}) where T\nfunction find_sum_central_node(graph::Graph{T}, nodes::Set{T}) where T\nfunction find_sum_central_node(graph::Graph{T}, nodes::Vector{T}) where T\n\nFinds the sum central node node of a Graph. Optionally, when nodes is specified, finds the central node with respect to the nodes.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#TenNetLib.find_eccentric_central_node-Union{Tuple{Graph{T}}, Tuple{T}, Tuple{Graph{T}, Union{Nothing, Set{T}}}} where T","page":"The Graph object","title":"TenNetLib.find_eccentric_central_node","text":"function find_eccentric_central_node(graph::Graph{T}) where T\nfunction find_eccentric_central_node(graph::Graph{T}, nodes::Set{T}) where T\nfunction find_eccentric_central_node(graph::Graph{T}, nodes::Vector{T}) where T\n\nFinds the eccentric central node of a Graph. Optionally, when nodes is specified, finds the central node with respect to the nodes.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#Base.copy-Union{Tuple{Graph{T}}, Tuple{T}} where T","page":"The Graph object","title":"Base.copy","text":"function Base.copy(graph::Graph{T}) where T\n\nShallow copy of Graph.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#Base.getindex-Union{Tuple{T}, Tuple{Graph{T}, T}} where T","page":"The Graph object","title":"Base.getindex","text":"function Base.getindex(graph::Graph{T}, node::T) where T\n\nReturns the edges for a given node::T as an index. \n\n\n\n\n\n","category":"method"},{"location":"base/graph/#Base.setindex!-Union{Tuple{T}, Tuple{Graph{T}, Set{T}, T}} where T","page":"The Graph object","title":"Base.setindex!","text":"function Base.setindex!(graph::Graph{T}, neighbors::Set{T}, node::T) where T\nfunction Base.setindex!(graph::Graph{T}, neighbors::Vector{T}, node::T) where T\n\nSets the edges=neighbors for a given node::T as an index.\n\n\n\n\n\n","category":"method"},{"location":"base/graph/#Base.:==-Union{Tuple{T}, Tuple{Graph{T}, Graph{T}}} where T","page":"The Graph object","title":"Base.:==","text":"function Base.:(==)(graph1::Graph{T}, graph2::Graph{T}) where T\n\nEquality between two Graph objects.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#OpStrings","page":"OpStrings","title":"OpStrings","text":"","category":"section"},{"location":"base/opstrings/","page":"OpStrings","title":"OpStrings","text":"TenNetLib.jl provides an alternative, called OpStrings, to ITensors.jl's OpSum to automatically construct Hamiltonains / operators. TenNetLib.jl's own CouplingModel is built from OpStrings and is not compatible with OpSum.","category":"page"},{"location":"base/opstrings/#OpString","page":"OpStrings","title":"OpString","text":"","category":"section"},{"location":"base/opstrings/","page":"OpStrings","title":"OpStrings","text":"OpStrings is basically a vector of OpString objects (notice the difference in 's' at the end)","category":"page"},{"location":"base/opstrings/#TenNetLib.OpString","page":"OpStrings","title":"TenNetLib.OpString","text":"struct OpString{T <: Number}\n    coeff::T\n    ops::Vector{Pair{String, Int}}\nend\n\nHolds operator strings (operator names with corresponding positions) along with the coefficient.\n\ncoeff::T: Coeffcient of the operator string.\nops::Vector{Pair{String, Int}}: String of operator names along with the positions.\n\n\n\n\n\n","category":"type"},{"location":"base/opstrings/#TenNetLib.coefficient-Tuple{OpString}","page":"OpStrings","title":"TenNetLib.coefficient","text":"function coefficient(opstr::OpString)\n\nReturns the coefficient of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.operators-Tuple{OpString}","page":"OpStrings","title":"TenNetLib.operators","text":"function operators(opstr::OpString)\n\nReturns the operator string of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.minsite-Tuple{OpString}","page":"OpStrings","title":"TenNetLib.minsite","text":"function minsite(opstr::OpString)\n\nReturns the lowest site position in the operator string of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.maxsite-Tuple{OpString}","page":"OpStrings","title":"TenNetLib.maxsite","text":"function maxsite(opstr::OpString)\n\nReturns the highest site position in the operator string of the OpString.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.removeIds-Union{Tuple{OpString{T}}, Tuple{T}} where T<:Number","page":"OpStrings","title":"TenNetLib.removeIds","text":"function removeIds(opstr::OpString{T}) where {T <: Number}\n\nReturns an OpString with all \"Id\" operators removed from the original.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.bosonize-Union{Tuple{T2}, Tuple{T1}, Tuple{OpString{T1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"OpStrings","title":"TenNetLib.bosonize","text":"function bosonize(opstr::OpString{T1},\n                  sites::Vector{Index{T2}}) where {T1 <: Number, T2}\n\nReturns an OpString after \"bosonizing\" the original with Jordan-Wigner strings as needed. See bosonize.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#OpStrings-2","page":"OpStrings","title":"OpStrings","text":"","category":"section"},{"location":"base/opstrings/#TenNetLib.OpStrings","page":"OpStrings","title":"TenNetLib.OpStrings","text":"const OpStrings{T} = Vector{OpString{T}}\n\nCollection of OpStrings.\n\nSyntax:\n\nos = OpStrings()\nos += 1, \"Sx\" => i, \"Sx\" => j, \"Sx\" => k, ....\nos += \"Sx\" => i, \"Sx\" => j, \"Sx\" => k, ....\n\nExample:\n\nos = OpStrings()    \nfor j=1:N-1\n    os += 1, \"Sz\" => j, \"Sz\" => j+1\n    os += 0.5, \"S+\" => j, \"S-\" => j+1\n    os += 0.5, \"S-\" => j, \"S+\" => j+1\nend\n\n\n\n\n\n","category":"type"},{"location":"base/opstrings/#TenNetLib.removeIdsZeros-Union{Tuple{Array{OpString{T}, 1}}, Tuple{T}} where T<:Number","page":"OpStrings","title":"TenNetLib.removeIdsZeros","text":"function removeIdsZeros(os::OpStrings{T}) where {T <: Number}\n\nReturns an OpStrings with all \"Id\" operators removed from the original, as well as any OpString term that has coeff less than Float64_threshold().\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.bosonize-Union{Tuple{T2}, Tuple{T1}, Tuple{Array{OpString{T1}, 1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"OpStrings","title":"TenNetLib.bosonize","text":"function bosonize(os::OpStrings{T1}, sites::Vector{Index{T2}}) where {T1 <: Number, T2}\n\nReturns an OpStrings after \"bosonizing\" the original with Jordan-Wigner strings as needed. See bosonize.\n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#TenNetLib.mergeterms-Union{Tuple{Array{OpString{T}, 1}}, Tuple{T}} where T<:Number","page":"OpStrings","title":"TenNetLib.mergeterms","text":"function mergeterms(os::OpStrings{T}) where T <: Number\n\nReturns an OpStrings where OpString elements with exactly same operator strings has been merged by adding the coefficients.  \n\n\n\n\n\n","category":"method"},{"location":"base/opstrings/#MPO-from-OpStrings","page":"OpStrings","title":"MPO from OpStrings","text":"","category":"section"},{"location":"base/opstrings/#ITensorMPS.MPO-Union{Tuple{T2}, Tuple{T1}, Tuple{Array{OpString{T1}, 1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"OpStrings","title":"ITensorMPS.MPO","text":"function ITensorMPS.MPO(os::OpStrings{T1},\n                        sites::Vector{Index{T2}};\n                        maxdim::Int = typemax(Int),\n                        mindim::Int = 1,\n                        cutoff::Float64 = Float64_threshold(),\n                        svd_alg::String = \"divide_and_conquer\",\n                        chunksize::Int = 12) where {T1 <: Number, T2}\n\nCreates MPO from os::OpStrings. The present version uses recursive SVDs to create the MPO. Very inefficient when number of Hamiltonian terms is large. Future updates will solve the problem.\n\nNamed arguments and their default values:\n\nmaxdim::Int = typemax(Int): Maximum MPO bond dimension after SVD truncation.\nmindim::Int = 1: Minimum MPO bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nchunksize::Int = 12. Maximum size of the chunks on which recursive SVDs are performed.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_gen/#Generating-TTN","page":"Generating TTN","title":"Generating TTN","text":"","category":"section"},{"location":"ttn/ttn_gen/","page":"Generating TTN","title":"Generating TTN","text":"TenNetLib.jl defines following functions to generate TTNs with random entries.","category":"page"},{"location":"ttn/ttn_gen/","page":"Generating TTN","title":"Generating TTN","text":"For the standard TTN with the default hierarchical binary tree structure, follwoing function can be used.","category":"page"},{"location":"ttn/ttn_gen/#TenNetLib.default_randomTTN","page":"Generating TTN","title":"TenNetLib.default_randomTTN","text":"function default_randomTTN(sites::Vector{Index{T}}, chi::Int, qn::QN = QN()) where T\n\nReturns a TTN object, having random elements, from site Indexs sites, initial bond dimension chi and (optional) global QN sector qn. The structure is a default hierarchical binary tree graph. Automatically handles situations where the number of sites is not a power of 2.\n\nNote: For QN conserving TTN, the bond dimension might be off by one or two from chi.\n\n\n\n\n\n","category":"function"},{"location":"ttn/ttn_gen/","page":"Generating TTN","title":"Generating TTN","text":"The underlying default binary tree for the function above is generated by the following function.","category":"page"},{"location":"ttn/ttn_gen/#TenNetLib.default_graph_sitenodes-Tuple{Int64}","page":"Generating TTN","title":"TenNetLib.default_graph_sitenodes","text":"function default_graph_sitenodes(N::Int)\n\nGiven the total number of sites, N::Int, generates the default hierarchical binary tree graph and a Dict{Int, Int2} object that maps each site to the corresponding node. Automatically handles situations where the number of sites is not a power of 2.\n\nReturn values:\n\n::Graph{Int2}: Default hierarchical tree graph to accomodate N number of sites in a TTN.\n::Dict{Int, Int2}: Maps each site to the corresponding node.\n\nExample:\n\ngraph, sitenodes = default_graph_sitenodes(32)\n\nsitenodes[1] == (1,1) # true\nsitenodes[2] == (1,1) # true\nsitenodes[3] == (1,2) # true\nsitenodes[4] == (1,2) # true\nsitenodes[31] == (1,16) # true\nsitenodes[32] == (1,16) # true\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_gen/","page":"Generating TTN","title":"Generating TTN","text":"In the generic scenario, a random TTN with user-defined structure can be generated by the following function.","category":"page"},{"location":"ttn/ttn_gen/#TenNetLib.randomTTN","page":"Generating TTN","title":"TenNetLib.randomTTN","text":"function randomTTN(sites::Vector{Index{T}}, graph::Graph{Int2},\n                   sitenodes::Dict{Int, Int2}, chi::Int, qn::QN = QN()) where T\n\nReturns a TTN object, having random elements, from site Indexs sites, the underlyting graph, sitenodes::Dict{Int, Int2} that maps each site to the corresponding node, initial bond dimension chi, and (optional) global QN sector qn. The structure is determined by the input graph object.\n\nNote: This function can be used to generate any loop-free tensor network.\n\nNote: For QN conserving TTN, the bond dimension might be off by one or two from chi.\n\n\n\n\n\n","category":"function"},{"location":"ttn/ttn_gen/","page":"Generating TTN","title":"Generating TTN","text":"info: Info\nThe above function can be used to generate any loop-free tensor network.","category":"page"},{"location":"mps/example_dmrg/#Example:-DMRG","page":"Example: DMRG","title":"Example: DMRG","text":"","category":"section"},{"location":"mps/example_dmrg/#Ground-state-search","page":"Example: DMRG","title":"Ground state search","text":"","category":"section"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"A straight-forward DMRG can be performed as follows.","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"using ITensors\nusing ITensorMPS\nusing TenNetLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpStrings()\n    \n    for j=1:N-1\n        os += 1, \"Sz\" => j, \"Sz\" => j+1\n        os += 0.5, \"S+\" => j, \"S-\" => j+1\n        os += 0.5, \"S-\" => j, \"S+\" => j+1\n    end\n    \n    H = CouplingModel(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    params = DMRGParams(;nsweeps = [10, 10], maxdim = [20, 50],\n                        cutoff = 1e-14, noise = 1e-3, noisedecay = 2,\n                        disable_noise_after = 5)\n\n    # dmrg2 for two-site DMRG\n    en, psi = dmrg2(psi0, H, params)\n\n    # or dmrg1 for single-site DMRG\n    # en, psi = dmrg1(psi0, H, params)\nend","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Here, we have used OpStrings and CouplingModel. Alternatively, standard OpSum and MPO can be used.","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Instead of using such higher-level code, one can also use lower-level functions for a better control.","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"sysenv = StateEnvs(psi0, H)\nnsite = 2 # two-site update\n\nswdata = dmrg!(sysenv, params, nsite)\n\n# Get energy from `Sweepdata`\nenergy = swdata.energy[end]\n\n# take a shallow copy of the MPS\n# if the `StateEnvs` will be updated later again\npsi = getpsi(sysenv)\n\n# Alternatively, take the psi from `StateEnvs` itself.\n# NOTE: This can crash the simulation, if the MPS is modified (e.g., in measurements)\n# and `StateEnvs` is going to be updated later on.\n# psi = sysenv.psi","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Most often, it is better to do a single-site DMRG (without any noise) after standard two-site update for better convergence. Such lower-level function using StateEnvs is useful for that.","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"sysenv = StateEnvs(psi0, H)\n\nparams2 = DMRGParams(;nsweeps = [10, 10], maxdim = [20, 50],\n                     cutoff = 1e-14, noise = 1e-3, noisedecay = 2,\n                     disable_noise_after = 5)\ndmrg!(sysenv, params2, 2)\n\nparams1 = DMRGParams(;nsweeps = [10], maxdim = [50], cutoff = 0.0)\ndmrg!(sysenv, params1, 1)","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Using such lower-level function, one can also restart the simulation at later times (e.g., by saving the StateEnvs using Serialization.jl), or one can perform updateH! to slowly change the Hamiltonian during DMRG simulations. ","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Global Subspace Expansion can also be used to get rid of nasty local minimas (if needed), if (and only if) the StateEnvs is built from a single MPO.","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"krylov_extend!(sysenv; extension_applyH_maxdim = 40)","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"warning: Warning\nGlobal Subspace Expansion may result into huge MPS bond dimension. That is why the named input parameters of krylov_extend! should be chosen carefully.","category":"page"},{"location":"mps/example_dmrg/#Excited-state-DMRG","page":"Example: DMRG","title":"Excited state DMRG","text":"","category":"section"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Excited state DMRG is also straightforword.","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"# Given a ground state `psi_gr`, initial MPS `psi0`,\n# and a Hamiltonian `H`\n\n# dmrg2 for two-site DMRG\nen, psi = dmrg2(psi0, H, [psi_gr], params; weight = 10.0)\n\n# or dmrg1 for single-site DMRG\n# en, psi = dmrg1(psi0, H, [psi_gr], params; weight = 10.0)","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"Similarly, using StateEnvs:","category":"page"},{"location":"mps/example_dmrg/","page":"Example: DMRG","title":"Example: DMRG","text":"sysenv_ex = StateEnvs(psi0, H, [psi_gr]; weight = 10.0)\nnsite = 2 # two-site update\n\nswdata_ex = dmrg!(sysenv_ex, params, nsite)\n\n# Get energy from `Sweepdata`\nenergy1 = swdata_ex.energy[end]\n\n# take a shallow copy of the MPS\n# if the `StateEnvs` will be updated later again\npsi1 = getpsi(sysenv_ex)\n\n# Alternatively, take the psi from `StateEnvs` itself.\n# NOTE: This can crash the simulation, if the MPS is modified (e.g., in measurements)\n# and `StateEnvs` is going to be updated later.\n# psi1 = sysenv_ex.psi","category":"page"},{"location":"ttn/optimize_ttn/#Optimizing-TTN","page":"Optimizing TTN","title":"Optimizing TTN","text":"","category":"section"},{"location":"ttn/optimize_ttn/","page":"Optimizing TTN","title":"Optimizing TTN","text":"Functions to optimize TTN.","category":"page"},{"location":"ttn/optimize_ttn/#OptimizeParamsTTN","page":"Optimizing TTN","title":"OptimizeParamsTTN","text":"","category":"section"},{"location":"ttn/optimize_ttn/","page":"Optimizing TTN","title":"Optimizing TTN","text":"TenNetLib.jl defines a struct, called  OptimizeParamsTTN, to control TTN optimizations.","category":"page"},{"location":"ttn/optimize_ttn/#TenNetLib.OptimizeParamsTTN","page":"Optimizing TTN","title":"TenNetLib.OptimizeParamsTTN","text":"mutable struct OptimizeParamsTTN\n    maxdim::Vector{Int}\n    nsweeps::Vector{Int}\n    cutoff::Vector{Float64}\n    noise::Vector{Float64}\n    noisedecay::Vector{Float64}\n    disable_noise_after::Vector{Int}\nend\n\nHolds parameters to control the optimzation sweeps of the TTN.\n\nmaxdim::Vector{Int}: Maximum allowed TTN bond/link dimensions at each stages of optimization.\nnsweeps::Vector{Int}: Number of sweeps to be performed at each statges of optimization.\ncutoff::Vector{Float64}: Cutoff for SVD truncation at each stages of optimization.\nnoise::Vector{Float64}: Noise level at each stages of optimization.\nnoisedecay::Vector{Float64}: Decay of noise level at each states of optimization.\n\nNoise is divided by noisedecay after each sweep.\n\ndisable_noise_after::Vector{Int}: Switch of noise after this many sweeps at each\n\nstates of optimization.\n\nAll these Vectors must have same dimension.\n\n\n\n\n\n","category":"type"},{"location":"ttn/optimize_ttn/#TenNetLib.OptimizeParamsTTN-Tuple{}","page":"Optimizing TTN","title":"TenNetLib.OptimizeParamsTTN","text":"function OptimizeParamsTTN(;maxdim::Vector{Int}, nsweeps::Vector{Int}, \n                           cutoff::Union{Vector{Float64}, Float64} = Float64_threshold(),\n                           noise::Union{Vector{Float64}, Float64, Int} = 0.0,\n                           noisedecay::Union{Vector{Float64}, Float64, Int} = 1.0,\n                           disable_noise_after::Union{Vector{Int}, Int} = typemax(Int))\n\nConstructor for OptimizeParamsTTN. Takes named arguments.\n\nmaxdim::Vector{Int}: Maximum allowed TTN bond/link dimensions at each stages of optimization.\nnsweeps::Vector{Int}: Number of sweeps to be performed at each statges of optimization.\ncutoff::Union{Float64, Vector{Float64}} = Float64_threshold(): Cutoff for SVD truncation at each stages of optimization. If Float64, cutoff remains same throughout the optimization simulation. \nnoise::Union{Float64, Int, Vector{Float64}} = 0.0: Noise level at each stages of optimization. If Float64 / Int, initial noise remains same throughout the optimization.\nnoisedecay::Union{Float64, Int, Vector{Float64}} = 1.0: Decay of noise level at each states of optimization. Noise is divided by noisedecay after each sweep. If Float64 / Int, noisedecay remains same throughout the DMRG simulation.\ndisable_noise_after::Union{Int, Vector{Int}} = typemax(Int): Switch of noise after this many sweeps at each states of optimization. If Int, disable_noise_after remains same throughout the optimization.\n\n\n\n\n\n","category":"method"},{"location":"ttn/optimize_ttn/#Base.copy-Tuple{OptimizeParamsTTN}","page":"Optimizing TTN","title":"Base.copy","text":"Base.copy(params::OptimizeParamsTTN)\n\nShallow copy OptimizeParamsTTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/optimize_ttn/#A-lower-level-optimization-function","page":"Optimizing TTN","title":"A lower level optimization function","text":"","category":"section"},{"location":"ttn/optimize_ttn/","page":"Optimizing TTN","title":"Optimizing TTN","text":"Following function modifies StateEnvsTTN in-place. Skip this function if you want to avoid lower-level abstraction.","category":"page"},{"location":"ttn/optimize_ttn/#TenNetLib.optimize!-Tuple{StateEnvsTTN, OptimizeParamsTTN, Vector{Tuple{Int64, Int64}}}","page":"Optimizing TTN","title":"TenNetLib.optimize!","text":"function optimize!(sysenv::StateEnvsTTN,\n                   params::OptimizeParamsTTN,\n                   sweeppath::Vector{Int2};\n                   kwargs...)\n\nPerforms optimization of the TTN.\n\nArguments:\n\nsysenv::StateEnvsTTN.\nparams::OptimizationParamsTTN.\nsweeppath::Vector{Int2}: The path to be followed during optimization sweep. A vector that must contain all the nodes atleast once.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state calculation. Must be set to greater than 0 for the excited state optimization.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: Optimization (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and the optimzation moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nNamed arguments for eig_solver and their default values:\n\nSee documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 3.\nsolver_maxiter::Int = 1.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\nSweepDataTTN\n\n\n\n\n\n","category":"method"},{"location":"ttn/optimize_ttn/#Higher-level-optimzation-functions","page":"Optimizing TTN","title":"Higher level optimzation functions","text":"","category":"section"},{"location":"ttn/optimize_ttn/#TenNetLib.optimize-Tuple{TTN, CouplingModel, OptimizeParamsTTN, Vector{Tuple{Int64, Int64}}}","page":"Optimizing TTN","title":"TenNetLib.optimize","text":"function optimize(psi0::TTN, H::CouplingModel,\n                  params::OptimizeParamsTTN,\n                  sweeppath::Vector{Int2};\n                  kwargs...)\n\nfunction optimize(psi0::TTN, H::CouplingModel, Ms::Vector{TTN},\n                  params::OptimizeParamsTTN,\n                  sweeppath::Vector{Int2};\n                  kwargs...)\n\nPerforms optimization of the TTN.\n\nArguments:\n\npsi0::TTN: Initial TTN.\nH::CouplingModel, Ms::Vector{MPS}.\nparams::OptimizationParamsTTN.\nsweeppath::Vector{Int2}: The path to be followed during optimization sweep. A vector that must contain all the nodes atleast once.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nsvd_alg::String = \"divide_and_conquer\".\nweight::Float64 = -1.0: Weight for the excited state calculation. Must be set to greater than 0 for the excited state optimization.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nConvergence criteria:\n\nenergyErrGoal: Optimization (at a particluar stage) stops when energy difference between two consecutive sweeps falls below this threshold and the optimzation moves to the next stage. noise must be below Float64_threshold() to trigger this early stopping.\n\nNamed arguments for eig_solver and their default values:\n\nSee documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 3.\nsolver_maxiter::Int = 1.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Energy.\n::TTN: The state psi.\n\n\n\n\n\n","category":"method"},{"location":"base/global/#Controlling-global-behaviors","page":"Controlling global behaviors","title":"Controlling global behaviors","text":"","category":"section"},{"location":"base/global/","page":"Controlling global behaviors","title":"Controlling global behaviors","text":"TenNetLib.jl provides following functions to control global behaviors for Tensor Network simulations.","category":"page"},{"location":"base/global/#TenNetLib.Float64_threshold","page":"Controlling global behaviors","title":"TenNetLib.Float64_threshold","text":"function Float64_threshold()\nfunction Float64_threshold(threshold::Float)\n\nReturns threshold for floating point calculations. In most cases, any number below this will be treated zero. E.g., in cutoff. Default: 1e-15.\n\nOptionally, change the threshold as per the input threshold.\n\n\n\n\n\n","category":"function"},{"location":"base/global/#TenNetLib.using_threaded_loop","page":"Controlling global behaviors","title":"TenNetLib.using_threaded_loop","text":"function using_threaded_loop()\nfunction using_threaded_loop(condition::Bool)\n\nReturns the condition whether to use threaded loop in inbuild TenNetLib.jl functions.\n\nOptionally, change the condition as per the input condition.\n\n\n\n\n\n","category":"function"},{"location":"base/global/#TenNetLib.@threaded_loop","page":"Controlling global behaviors","title":"TenNetLib.@threaded_loop","text":"macro threaded_loop(code)\n\nConditional threaded loop by Threads.@threads. If using_threaded_loop() returns true, performs parallel loop, otherwise performs serial loop.\n\nNote: All other forms of parallelization are switched off inside the loop body, if parallel loop is being executed.\n\nExample:\n\n@threaded_loop for i = 1 : N\n    # Do stuff in parallel\nend\n\n\n\n\n\n","category":"macro"},{"location":"ttn/sweep_ttn/#Sweeping-through-the-TTN","page":"Sweeping through the TTN","title":"Sweeping through the TTN","text":"","category":"section"},{"location":"ttn/sweep_ttn/","page":"Sweeping through the TTN","title":"Sweeping through the TTN","text":"At a lower level of abstraction, TenNetLib.jl allows to control each fullsweep  manually to update StateEnvsTTN.","category":"page"},{"location":"ttn/sweep_ttn/","page":"Sweeping through the TTN","title":"Sweeping through the TTN","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"ttn/sweep_ttn/#SweepDataTTN","page":"Sweeping through the TTN","title":"SweepDataTTN","text":"","category":"section"},{"location":"ttn/sweep_ttn/","page":"Sweeping through the TTN","title":"Sweeping through the TTN","text":"TenNetLib.jl defines a struct, called  SweepDataTTN, to store essential data after each fullsweep.","category":"page"},{"location":"ttn/sweep_ttn/#TenNetLib.SweepDataTTN","page":"Sweeping through the TTN","title":"TenNetLib.SweepDataTTN","text":"mutable struct SweepDataTTN\n    sweepcount::Int\n    maxchi::Vector{Int}\n    energy::Vector{Float64}\nend\n\nHolds historical data after each (full)sweep of the TTN. Requires for convergence check etc.\n\nsweepcount::Int: Number of fullsweeps performed.\nmaxchi::Vector{Int}: Maximum MPS bond/link dimensions after every sweep.\nenergy::Vector{Float64}: Energies after every sweep.\n\nDefault constructor:\n\nSweepDataTTN(): Initialize an empty SweepData object.\n\n\n\n\n\n","category":"type"},{"location":"ttn/sweep_ttn/#Base.copy-Tuple{SweepDataTTN}","page":"Sweeping through the TTN","title":"Base.copy","text":"Base.copy(swdata::SweepDataTTN)\n\nShallow copy of SweepDataTTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/sweep_ttn/#sweeppath","page":"Sweeping through the TTN","title":"sweeppath","text":"","category":"section"},{"location":"ttn/sweep_ttn/#TenNetLib.default_sweeppath","page":"Sweeping through the TTN","title":"TenNetLib.default_sweeppath","text":"function default_sweeppath(psi::TTN)\n\nFor a given a TTN having the default hierarchical binary tree structure, teturns the default path for sweeping through the TTN.\n\nReturn values:\n\nVector{Int2}: The list of nodes as the path to be followed during a (half)sweep.\n\n\n\n\n\n","category":"function"},{"location":"ttn/sweep_ttn/#Perform-a-fullsweep","page":"Sweeping through the TTN","title":"Perform a fullsweep","text":"","category":"section"},{"location":"ttn/sweep_ttn/#TenNetLib.fullsweep!-Tuple{StateEnvsTTN, Vector{Tuple{Int64, Int64}}, Any, SweepDataTTN}","page":"Sweeping through the TTN","title":"TenNetLib.fullsweep!","text":"function fullsweep!(sysenv::StateEnvsTTN, sweeppath::Vector{Int2}, solver,\n                    swdata::SweepDataTTN; kwargs...)\n\nPerform a fullsweep of the TTN by solver.\n\nArguments:\n\nsysenv::StateEnvsTTN.\nsweeppath::Vector{Int2}: The list of nodes as the path to be followed during a (half)sweep. Must have each node atleast once. For the next halfsweep the reverse path is followed.\nsolver: Solver for update. Currently only eig_solver is supported.\nswdata::SweepDataTTN.\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for future functionality.\nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nexpand_dim::Int = 0 if noise == 0 else 20. Dimension to be expanded (on top of maxdim) during subspace expansion.\nmax_expand_dim::Int = 2 * expand_dim. maximum dimension to be expanded during subspace expansion.\nexpand_numiter::Int = 4. Number of iteration for subspace expansion. Should be greater than 1.\nlinkwise_maxdim::Union{Nothing, Dict{LinkTypeTTN, Int}} = nothing. Specifies maximum bond dimension of a particular link.  \noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Change in Energy ΔE\n\nswdata::SweepDataTTN gets updated.\n\n\n\n\n\n","category":"method"},{"location":"base/solver/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"base/solver/","page":"Solvers","title":"Solvers","text":"Functions to perform local updates. These functions use Krylovkit.jl.","category":"page"},{"location":"base/solver/#TenNetLib.eig_solver","page":"Solvers","title":"TenNetLib.eig_solver","text":"function eig_solver(env, phi0::ITensor, time_step::Nothing; kwargs...)\n\nSolver to find smallest eigenvalue corresponding to \"matrix\" env and input vector phi0.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Smallest eigenvalue.\n::ITensor: Eigenstate corresponding to the smallest eigenvalue.\n\n\n\n\n\n","category":"function"},{"location":"base/solver/#TenNetLib.exp_solver","page":"Solvers","title":"TenNetLib.exp_solver","text":"function exp_solver(env, phi0::ITensor, time_step::Union{Float64, ComplexF64}; kwargs...)\n\nExponentiation solver to find exp(env * phi0 * time_step).\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true\nsolver_tol::Float64 = 1E-12.\nsolver_krylovdim::Int = 30.\nsolver_maxiter::Int = 10.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = true.\nsolver_check_convergence::Bool = true.\n\nReturn values:\n\n::Float64: NaN. \n::ITensor: Exponentiated ITensor.\n\n\n\n\n\n","category":"function"},{"location":"ttn/update_site_ttn/#Perform-local-updates","page":"Perform local updates","title":"Perform local updates","text":"","category":"section"},{"location":"ttn/update_site_ttn/","page":"Perform local updates","title":"Perform local updates","text":"At the lowest-level of abstraction, TenNetLib.jl allows for updating the StateEnvsTTN for each sites manually.","category":"page"},{"location":"ttn/update_site_ttn/","page":"Perform local updates","title":"Perform local updates","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"ttn/update_site_ttn/#TenNetLib.update_position!-Tuple{StateEnvsTTN, Any, Tuple{Int64, Int64}}","page":"Perform local updates","title":"TenNetLib.update_position!","text":"function update_position!(sysenv::StateEnvsTTN, solver, node::Int2;\n                          time_step::Union{Float64, ComplexF64, Nothing},\n                          normalize::Bool,\n                          maxdim::Int,\n                          mindim::Int,\n                          cutoff::Float64,\n                          svd_alg::String,\n                          kwargs...)\n\nMoves the orthogonality center to pos and update StateEnvsTTN at position pos by solver.\n\nArguments:\n\nsysenv::StateEnvsTTN\nsolver: Solver for update. Currently only eig_solver is supported.\npos::Int: Position of the node to be updated.\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for future functionality.\nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14.\nsolver_krylovdim::Int = 5.\nsolver_maxiter::Int = 2.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false.\nsolver_check_convergence::Bool = false.\n\nReturn values:\n\n::Float64: Energy.\n\n\n\n\n\n","category":"method"},{"location":"ttn/update_site_ttn/","page":"Perform local updates","title":"Perform local updates","text":"TenNetLib.jl implements the subspace expansion method described in SciPost Phys. Lect. Notes 8 (2019) to increase the bond dimension between two neighboring nodes.","category":"page"},{"location":"ttn/update_site_ttn/#TenNetLib.subspace_expand!-Tuple{TTN, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Int64, Float64}","page":"Perform local updates","title":"TenNetLib.subspace_expand!","text":"function subspace_expand!(psi::TTN, node::Int2, nextnode::Int2,\n                          max_expand_dim::Int, noise::Float64)\n\nEnlarges the bond domension between node and nextnode by max_expand_dim using the subspace expansion. The parameter noise controls stength of the perturbation.\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#CouplingModel","page":"CouplingModel","title":"CouplingModel","text":"","category":"section"},{"location":"base/couplingmodel/","page":"CouplingModel","title":"CouplingModel","text":"TenNetLib.jl degines as struct, called the CouplingModel, to store the Hamiltonian terms.  In case of MPS based algorithms, CouplingModel can replace MPO without modifying rest of the code. For Tree Tensor Network (TTN) codes, only CouplingModel can be used. Different elements of CouplingModel are contracted in parallel.","category":"page"},{"location":"base/couplingmodel/#TenNetLib.CouplingModel","page":"CouplingModel","title":"TenNetLib.CouplingModel","text":"struct CouplingModel\n    sites::Vector{Index}\n    terms::Vector{IDTensors}\nend\n\nCouplingModel for a given OpStrings Hamiltonian terms and sites::Vector{Index}.\n\nsites::Vector{Index}: Site Indexs.\nterms::Vector{IDTensors}: Collection of Hamiltonian terms. \n\n\n\n\n\n","category":"type"},{"location":"base/couplingmodel/#TenNetLib.CouplingModel-Union{Tuple{T2}, Tuple{T1}, Tuple{Array{OpString{T1}, 1}, Array{Index{T2}, 1}}} where {T1<:Number, T2}","page":"CouplingModel","title":"TenNetLib.CouplingModel","text":"function CouplingModel(os::OpStrings,\n                       sites::Vector{Index};\n                       merge::Bool = true,\n                       maxdim::Int = typemax(Int),\n                       mindim::Int = 1,\n                       cutoff::Float64 = Float64_threshold(),\n                       svd_alg::String = \"divide_and_conquer\",\n                       chunksize::Int = 12)\n\nConstructor of the CouplingModel from os::OpStrings and sites::Vector{Index}.\n\nNamed arguments and their default values:\n\nmerge::Bool = true. If true, merges all the terms having same spatial support resulting in larger virtual dimension. Otherwise, all the terms have virtual dimension one.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_Threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nchunksize::Int = 12.\n\nExample:\n\nos = OpStrings()    \nfor j=1:N-1\n    os += 1, \"Sz\" => j, \"Sz\" => j+1\n    os += 0.5, \"S+\" => j, \"S-\" => j+1\n    os += 0.5, \"S-\" => j, \"S+\" => j+1\nend    \nH = CouplingModel(os,sites)\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#TenNetLib.CouplingModel-Union{Tuple{T1}, Tuple{Array{OpString{T1}, 1}, MPO}} where T1<:Number","page":"CouplingModel","title":"TenNetLib.CouplingModel","text":"function CouplingModel(os::OpStrings,\n                       mpo::MPO;\n                       merge::Bool = true,\n                       maxdim::Int = typemax(Int),\n                       mindim::Int = 1,\n                       cutoff::Float64 = Float64_threshold(),\n                       svd_alg::String = \"divide_and_conquer\",\n                       chunksize::Int = 12)\n\nConstructor of the CouplingModel from os::OpStrings and mpo::MPO. Resultant CouplingModel is the sum of os and the mpo.\n\nNamed arguments and their default values:\n\nmerge::Bool = true. If true, merges all the terms having same spatial support resulting in larger virtual dimension. Otherwise, all the terms have virtual dimension one.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_Threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nchunksize::Int = 12.\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#TenNetLib.CouplingModel-Tuple{Vararg{MPO}}","page":"CouplingModel","title":"TenNetLib.CouplingModel","text":"function CouplingModel(mpos::MPO...)\n\nConstructs CouplingModel from a collection of MPOs. Different MPO terms can be contracted in parallel during different MPS/TTN algorithms. Useful for TTN codes.\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#Base.length-Tuple{CouplingModel}","page":"CouplingModel","title":"Base.length","text":"function Base.length(model::CouplingModel)\n\nNumber of sites in the system.\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#Base.copy-Tuple{CouplingModel}","page":"CouplingModel","title":"Base.copy","text":"function Base.copy(model::CouplingModel)\n\nShallow copy of CouplingModel.\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#Base.getindex-Tuple{CouplingModel, Any}","page":"CouplingModel","title":"Base.getindex","text":"function Base.getindex(model::CouplingModel, n)\n\nReturns Hamiltonian terms for nth site(s) in the CouplingModel.\n\n\n\n\n\n","category":"method"},{"location":"base/couplingmodel/#ITensors.SiteTypes.siteinds-Tuple{CouplingModel}","page":"CouplingModel","title":"ITensors.SiteTypes.siteinds","text":"function ITensorMPS.siteinds(model::CouplingModel)\n\nReturns the site Indexs of the CouplingModel.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#Performing-TDVP","page":"Performing TDVP","title":"Performing TDVP","text":"","category":"section"},{"location":"mps/tdvp/#TDVPEngine","page":"Performing TDVP","title":"TDVPEngine","text":"","category":"section"},{"location":"mps/tdvp/","page":"Performing TDVP","title":"Performing TDVP","text":"TenNetLib.jl defines a struct, called TDVPEngine, to store essential data during TDVP sweeps.","category":"page"},{"location":"mps/tdvp/#TenNetLib.TDVPEngine","page":"Performing TDVP","title":"TenNetLib.TDVPEngine","text":"mutable struct TDVPEngine{T <: Union{ProjMPO,\n                                     ProjMPOSum2,\n                                     ProjMPO_MPS2,\n                                     ProjMPOSum_MPS,\n                                     ProjCouplingModel,\n                                     ProjCouplingModel_MPS}}\n\nHolds the MPS state, SweepData, and absolute elpased time for TDVP simulations.\n\nsysenv::StateEnvs: Holds the state psi and environments PH.\nswdata::SweepData: Holds the historical data after each (full)sweep.\nabstime::Float64: Absolute elapsed time.\n\n\n\n\n\n","category":"type"},{"location":"mps/tdvp/#TenNetLib.TDVPEngine-Union{Tuple{T}, Tuple{MPS, T}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TenNetLib.TDVPEngine","text":"function TDVPEngine(psi::MPS, H::{T}) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nConstructor of the TDVPEngine from different forms of Hamiltonians.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.TDVPEngine-Union{Tuple{T}, Tuple{MPS, T, Vector{MPS}}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TenNetLib.TDVPEngine","text":"function TDVPEngine(psi::MPS, H::T, Ms::Vector{MPS};\n                    weight::Float64) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nConstructor of TDVPEngine from different forms of Hamiltonians and a vector of MPS.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.getpsi-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.getpsi","text":"function getpsi(engine::TDVPEngine)\n\nReturns (shallow copy of) the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.sweepcount-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.sweepcount","text":"function sweepcount(engine::TDVPEngine)\n\nReturns the number of sweeps performed.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.getenergy-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.getenergy","text":"function getenergy(engine::TDVPEngine)\n\nReturns the energy of the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.getentropy-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.getentropy","text":"function getentropy(engine::TDVPEngine)\n\nReturns the mid-chain entropy of the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.maxchi-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.maxchi","text":"function maxchi(engine::TDVPEngine)\n\nReturns the maximum bond/link dimension of the state psi.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.totalerror-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.totalerror","text":"function totalerror(engine::TDVPEngine)\n\nReturns the sum of the truncation errors of all the sweeps performed.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.sweeperror-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.sweeperror","text":"function sweeperror(engine::TDVPEngine)\n\nReturns the truncation error in the last sweep.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.krylov_extend!-Tuple{TDVPEngine{ProjMPO}}","page":"Performing TDVP","title":"TenNetLib.krylov_extend!","text":"function krylov_extend!(engine::TDVPEngine{ProjMPO}; kwargs...)\n\nPerforms Global Subspace Expansion.\n\nArguments and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.sweepdata-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.sweepdata","text":"function sweepdata(engine::TDVPEngine)\n\nReturns the (shallow copy of) SweepData.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.abstime-Tuple{TDVPEngine}","page":"Performing TDVP","title":"TenNetLib.abstime","text":"function abstime(engine::TDVPEngine)\n\nReturns the absolute elapsed time.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.updateH!-Union{Tuple{T}, Tuple{TDVPEngine, T}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TenNetLib.updateH!","text":"function updateH!(engine::TDVPEngine, H::T;\n                  recalcEnv::Bool = true) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nUpdate Hamiltonian H in engine::TDVPEngine. If recalcEnv = false, it reuses previous environments. recalcEnv = false is only defined when the TDVPEngine is created from a single MPO.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#TenNetLib.updateH!-Union{Tuple{T}, Tuple{TDVPEngine, T, Vector{MPS}}} where T<:Union{MPO, CouplingModel, Vector{MPO}}","page":"Performing TDVP","title":"TenNetLib.updateH!","text":"function updateH!(engine::TDVPEngine, H::T, Ms::Vector{MPS};\n                  weight::Float64,\n                  recalcEnv::Bool = true) where T <: Union{MPO, Vector{MPO}, CouplingModel}\n\nUpdate Hamiltonian H in engine::TDVPEngine. recalcEnv = false is not supported.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#Base.copy-Tuple{TDVPEngine}","page":"Performing TDVP","title":"Base.copy","text":"Base.copy(engine::TDVPEngine)\n\nShallow copy of TDVPEngine.\n\n\n\n\n\n","category":"method"},{"location":"mps/tdvp/#tdvpsweep!","page":"Performing TDVP","title":"tdvpsweep!","text":"","category":"section"},{"location":"mps/tdvp/","page":"Performing TDVP","title":"Performing TDVP","text":"Following function performs one TDVP sweep.","category":"page"},{"location":"mps/tdvp/#TenNetLib.tdvpsweep!","page":"Performing TDVP","title":"TenNetLib.tdvpsweep!","text":"tdvpsweep!(engine::TDVPEngine, time_step::Union{Float64, ComplexF64}; \n           nsite::Union{Int, String} = \"dynamic\", \n           solver = exp_solver,\n           kwargs...)::Nothing\n\nPerforms one TDVP sweep. Computes ψ' = exp(time_step * H) * ψ. Therefore, for real-time dynamics with step dt, time_step should be -im * dt. \n\nArguments:\n\nengine::TDVPEngine.\ntime_step::Union{Float64, ComplexF64}.\nnsite::Union{Int, String} = \"dynamic\": For two or one site sweeps, nsite=2 or nsite=1 respectively. For nsite=\"dynamic\", dynamic_fullsweep! is performed.\nsolver = exp_solver: Only exp_solver is supported now.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\neigthreshold::Float64 = 1E-12. Only applicable for nsite = \"dynamic\" (see dynamic_fullsweep!).\nextendat::Union{Nothing, Int} = nothing: If specified, at every extendatth sweep, Global Subspace Expansion is performed followed by a pure one-site sweep if typeof(sysenv) == StateEnvs{ProjMPO}, else performs a full two-site sweep. Only applicable for nsite = \"dynamic\" (see dynamic_fullsweep!).\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-12.\nsolver_krylovdim::Int = 30.\nsolver_maxiter::Int = 100.\nsolver_outputlevel::Int = 0.: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = true.\nsolver_check_convergence::Bool = true.\n\nArguments for Global Subspace Expansion and their default values:\n\nOnly applicable for nsite = \"dynamic\" (see dynamic_fullsweep!).\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"function"},{"location":"ttn/state_envs_ttn/#StateEnvsTTN:-A-container-to-store-the-TTN-and-its-environments","page":"StateEnvsTTN","title":"StateEnvsTTN: A container to store the TTN and its environments","text":"","category":"section"},{"location":"ttn/state_envs_ttn/","page":"StateEnvsTTN","title":"StateEnvsTTN","text":"Similar to the setup for MPS, at the lowest-level of abstraction, TenNetLib.jl defines StateEnvs to hold a TTN and its environments to be modified in place.","category":"page"},{"location":"ttn/state_envs_ttn/","page":"StateEnvsTTN","title":"StateEnvsTTN","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"ttn/state_envs_ttn/#TenNetLib.StateEnvsTTN","page":"StateEnvsTTN","title":"TenNetLib.StateEnvsTTN","text":"mutable struct StateEnvsTTN{T1, T2 <: Union{EnvCouplingModelTTN,\n                                            EnvCouplingModelProjTTN}}\n    psi::TTN{T1}\n    env::T{T2}\nend\n\nHolds the TTN and the environment.\n\n\n\n\n\n","category":"type"},{"location":"ttn/state_envs_ttn/#TenNetLib.StateEnvsTTN-Tuple{TTN, CouplingModel}","page":"StateEnvsTTN","title":"TenNetLib.StateEnvsTTN","text":"function StateEnvsTTN(psi::TTN, H::CouplingModel)\n\nConstructor of the StateEnvsTTN from a CouplingModel. Each terms in the CouplingModel are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"ttn/state_envs_ttn/#TenNetLib.StateEnvsTTN-Tuple{TTN, CouplingModel, Vector{TTN}}","page":"StateEnvsTTN","title":"TenNetLib.StateEnvsTTN","text":"function StateEnvsTTN(psi::TTN, H::CouplingModel, Ms::Vector{TTN}; weight::Float64)\n\nConstructor of StateEnvsTTN from a CouplingModel and a vector of TTN used for excited state search. Each terms in the CouplingModel are contracted in parallel.\n\n\n\n\n\n","category":"method"},{"location":"ttn/state_envs_ttn/#TenNetLib.getpsi-Tuple{StateEnvsTTN}","page":"StateEnvsTTN","title":"TenNetLib.getpsi","text":"function getpsi(sysenv::StateEnvsTTN)\n\nReturns (shallow copy of) the state psi.\n\n\n\n\n\n","category":"method"},{"location":"ttn/state_envs_ttn/#TenNetLib.getenv-Tuple{StateEnvsTTN}","page":"StateEnvsTTN","title":"TenNetLib.getenv","text":"function getenv(sysenv::StateEnvsTTN)\n\nReturns (shallow copy of) the environment env.\n\n\n\n\n\n","category":"method"},{"location":"ttn/state_envs_ttn/#ITensorMPS.position!-Tuple{StateEnvsTTN, Tuple{Int64, Int64}}","page":"StateEnvsTTN","title":"ITensorMPS.position!","text":"function position!(sysenv::StateEnvsTTN, node::Int2;\n                   maxdim::Int = typemax(Int),\n                   mindim::Int = 1,\n                   cutoff::Float64 = Float64_threshold(),\n                   svd_alg::String = \"divide_and_conquer\",\n                   normalize::Bool = true)\n\nMoves the orthogonality center of the TTN to node and updates the effective Hamiltonian of the same.\n\nNamed arguments and their default values:\n\nnormalize::Bool = true: Whether to normalize afterwards.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\n\n\n\n\n\n","category":"method"},{"location":"ttn/state_envs_ttn/#TenNetLib.product-Tuple{StateEnvsTTN, ITensor}","page":"StateEnvsTTN","title":"TenNetLib.product","text":"function product(sysenv::StateEnvsTTN, v::ITensor)\n\nReturns the Matrix-Vector product between the environment and input ITensor v.\n\n\n\n\n\n","category":"method"},{"location":"ttn/state_envs_ttn/#Base.copy-Tuple{StateEnvsTTN}","page":"StateEnvsTTN","title":"Base.copy","text":"function Base.copy(sysenv::StateEnvsTTN)\n\nShallow copy of StateEnvsTTN.\n\n\n\n\n\n","category":"method"},{"location":"mps/update_site/#Perform-local-updates","page":"Perform local updates","title":"Perform local updates","text":"","category":"section"},{"location":"mps/update_site/","page":"Perform local updates","title":"Perform local updates","text":"At the lowest-level of abstraction, TenNetLib.jl allows for updating the StateEnvs for each sites/bonds manually.","category":"page"},{"location":"mps/update_site/","page":"Perform local updates","title":"Perform local updates","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/update_site/#TenNetLib.update_position!-Tuple{StateEnvs, Any, Int64, Int64, String}","page":"Perform local updates","title":"TenNetLib.update_position!","text":"update_position!(sysenv::StateEnvs, solver, pos::Int, nsite::Int, ortho::String; kwargs...)\n\nUpdates StateEnvs at position pos by solver.\n\nArguments:\n\nsysenv::StateEnvs\nsolver: Solver for update. Available ones: eig_solver and exp_solver.\npos::Int: Position of the bond (nsite=2) or site (nsite=1).\nnsite of the environment. Either 1 or 2 for one-site or two-site update respectively.\northo::String: Direction of the sweep. Either \"left\" or \"right\".\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for TDVP. \nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nreverse_step::Bool = false if time_step = nothing, true otherwise.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14 if eig_solver, 1E-12 if exp_solver.\nsolver_krylovdim::Int = 5 if eig_solver, 30 if exp_solver.\nsolver_maxiter::Int = 2 if eig_solver, 100 if exp_solver.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false if eig_solver, true if exp_solver.\nsolver_check_convergence::Bool = false if eig_solver, true if exp_solver.\n\nReturn values:\n\n::Float64: Energy.\n::Float64: Truncation Error.\n::Vector{Float64}: SVD spectrum.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#The-TTN-object","page":"The TTN object","title":"The TTN object","text":"","category":"section"},{"location":"ttn/ttn_struct/#TenNetLib.TTN","page":"The TTN object","title":"TenNetLib.TTN","text":"mutable struct TTN{T}\n    sites::Vector{Index{T}}\n    graph::Graph{Int2}\n    tensors::Dict{Int2, ITensor}\n    orthocenter::Int2\nend\n\nTree Tensor Network (TTN) object.\n\nEach tensor is indexed by the tuple of integers (::Int2), (ll, nn), where (usually) ll denotes the layer index and nn denotes the tensor index at each layer.\n\nsites::Vector{Index}: Physical site Indexs.\ngraph::Graph{Int2}: Underlying structure of the network defined by Graph{Int2}.\ntensors::Dict{Int2, ITensor}: Tensors in the TTN.\northocenter::Int2: Orthogonality center of the TTN.\n\n\n\n\n\n","category":"type"},{"location":"ttn/ttn_struct/#ITensors.SiteTypes.siteinds-Tuple{TTN}","page":"The TTN object","title":"ITensors.SiteTypes.siteinds","text":"function ITensors.siteinds(ttn::TTN)\n\nReturns the site Indexs of the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#ITensors.SiteTypes.siteind-Tuple{TTN, Int64}","page":"The TTN object","title":"ITensors.SiteTypes.siteind","text":"function ITensors.siteind(ttn::TTN, n::Int)\n\nReturns the nth site Index of the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.numsites-Tuple{TTN}","page":"The TTN object","title":"TenNetLib.numsites","text":"function numsites(ttn::TTN)\n\nReturns the number of physical sites in the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.getgraph-Tuple{TTN}","page":"The TTN object","title":"TenNetLib.getgraph","text":"function getgraph(ttn::TTN)\n\nReturns (shallow copy of) the underlying graph of the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#Base.getindex-Tuple{TTN, Tuple{Int64, Int64}}","page":"The TTN object","title":"Base.getindex","text":"function Base.getindex(ttn::TTN, node::Int2)\nfunction Base.getindex(ttn::TTN, ll::Int, nn::Int)\n\nReturns the tensor at the node::Int2 = (ll, nn).\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#Base.setindex!-Tuple{TTN, ITensor, Tuple{Int64, Int64}}","page":"The TTN object","title":"Base.setindex!","text":"function Base.setindex!(ttn::TTN, tensor::ITensor, node::Int2)\nfunction Base.setindex!(ttn::TTN, tensor::ITensor, ll::Int, nn::Int)\n\nSets the tensor at the node::Int2 = (ll, nn). If the node is not the orthogonality center, orthogonality center is set to (typemin(Int), typemin(Int)).\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#ITensorMPS.orthocenter-Tuple{TTN}","page":"The TTN object","title":"ITensorMPS.orthocenter","text":"function orthocenter(ttn::TTN)\n\nReturns the orthogonality center of the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#Base.copy-Tuple{TTN}","page":"The TTN object","title":"Base.copy","text":"Base.copy(ttn::TTN)\n\nShallow copy of TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.isvalidnode-Tuple{TTN, Tuple{Int64, Int64}}","page":"The TTN object","title":"TenNetLib.isvalidnode","text":"function isvalidnode(ttn::TTN, node::Int2)\n\nChecks whether the input node::Int2 is a valid node in the TTN graph.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.isneighbor-Tuple{TTN, Tuple{Int64, Int64}, Tuple{Int64, Int64}}","page":"The TTN object","title":"TenNetLib.isneighbor","text":"function isneighbor(ttn::TTN, node1::Int2, node2::Int2)\n\nChecks whether node1 and node2 are neighboring nodes in the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#ITensorMPS.findsite-Tuple{TTN, Any}","page":"The TTN object","title":"ITensorMPS.findsite","text":"function ITensors.findsite(ttn::TTN, is)\n\nReturns the first site of the TTN that has at least one Index in common with the Index or ITensor or their collection is.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#ITensorMPS.findsites-Tuple{TTN, Any}","page":"The TTN object","title":"ITensorMPS.findsites","text":"function ITensors.findsites(ttn::TTN, is)\n\nReturns the sites of the TTN that have Indexs in common with the Index or ITensor or their collection is.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.findnode-Tuple{TTN, Any}","page":"The TTN object","title":"TenNetLib.findnode","text":"function findnode(ttn::TTN, is)\n\nReturns the first node of the TTN that has at least one Index in common with the Index or ITensor or their collection is.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.findnodes-Tuple{TTN, Any}","page":"The TTN object","title":"TenNetLib.findnodes","text":"function findnodes(ttn::TTN, is)\n\nReturns the nodes of the TTN that have Indexs in common with the Index or ITensor or their collection is.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.find_sitenode-Tuple{TTN, Int64}","page":"The TTN object","title":"TenNetLib.find_sitenode","text":"function find_sitenode(ttn::TTN, n::Int)\n\nReturn node of the TTN that is associated with the site n. \n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.find_sitenodes-Tuple{TTN, Any}","page":"The TTN object","title":"TenNetLib.find_sitenodes","text":"function find_sitenodes(ttn::TTN, ns)\n\nReturns nodes of the TTN that are associated with the sites ns (a collection of Ints). \n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#ITensorMPS.maxlinkdim-Tuple{TTN}","page":"The TTN object","title":"ITensorMPS.maxlinkdim","text":"function ITensors.maxlinkdim(ttn::TTN)\n\nReturns the maximum bond/link dimension of the TTN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#LinearAlgebra.normalize!-Tuple{TTN}","page":"The TTN object","title":"LinearAlgebra.normalize!","text":"function LinearAlgebra.normalize!(ttn::TTN)\n\nNormalizes the TTN. The TTN must have well-defined orthogonality center.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/","page":"The TTN object","title":"The TTN object","text":"info: Info\nTo conserve global symmetry in TTN, TenNetLib.jl uses a dummy index of dimension one whose flux fixes the superselection sector. This dummy index is attached to one of the tensors of TTN, usually the eccentric central node. Unlike MPS, the fluxes of all tensors in TTN are zero.","category":"page"},{"location":"ttn/ttn_struct/#ITensors.hasqns-Tuple{TTN}","page":"The TTN object","title":"ITensors.hasqns","text":"function ITensors.hasqns(ttn::TTN)\n\nChecks whether the TTN has QNs.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.find_qnnode-Tuple{TTN{Vector{Pair{QN, Int64}}}}","page":"The TTN object","title":"TenNetLib.find_qnnode","text":"function find_qnnode(ttn::TTN)\n\nReturns the node where the a dummy QN Index is attached to fix the QN sector. Returns nothing if the TTN does not have QN.\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.moveisometry_to_next!-Tuple{TTN, Tuple{Int64, Int64}, Tuple{Int64, Int64}}","page":"The TTN object","title":"TenNetLib.moveisometry_to_next!","text":"function moveisometry_to_next!(ttn::TTN, node1::Int2, node2::Int2; kwargs...)\n\nMoves the isometry / orthogonality center of the TTN from node1::Int2 to the neighboring node2::Int. node1 and node2 must be neighboring nodes. node1 must be the orthogonality center unless ignore_orthocenter = true.\n\nNote: Does not normalize the TTN afterwards.\n\nNamed arguments and their default values.\n\nignore_orthocenter::Bool = false: If set to true, node1 is not required to be the orthogonality center.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.isometrize_full!-Tuple{TTN, Tuple{Int64, Int64}}","page":"The TTN object","title":"TenNetLib.isometrize_full!","text":"function isometrize_full!(ttn::TTN, node::Int2; kwargs...)\n\nIsometrizes the TTN from scratch with respect to the orthogonality center node::Int2.\n\nNamed arguments and their default values.\n\nnormalize::Bool = true: Whether to normalize the TTN afterwards.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\". \n\n\n\n\n\n","category":"method"},{"location":"ttn/ttn_struct/#TenNetLib.isometrize!-Tuple{TTN, Tuple{Int64, Int64}}","page":"The TTN object","title":"TenNetLib.isometrize!","text":"function isometrize!(ttn::TTN, node::Int2; kwargs...)\n\nMoves the isometry / orthogonality center of the TTN to a new center node. If the TTN does not have proper orthoginality center, Isometrizes the TTN from scratch.\n\nNamed arguments and their default values.\n\nnormalize::Bool = true: Whether to normalize the TTN afterwards.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\". \n\n\n\n\n\n","category":"method"},{"location":"mps/sweep/#Sweeping-through-the-MPS","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"","category":"section"},{"location":"mps/sweep/","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"At a lower level of abstraction, TenNetLib.jl allows to control each fullsweep (left-to-right and right-to-left) manually to update StateEnvs.","category":"page"},{"location":"mps/sweep/","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"Skip this part if you want to avoid lower-level abstraction.","category":"page"},{"location":"mps/sweep/#SweepData","page":"Sweeping through the MPS","title":"SweepData","text":"","category":"section"},{"location":"mps/sweep/","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"TenNetLib.jl defines a struct, called  SweepData, to store essential data after each fullsweep.","category":"page"},{"location":"mps/sweep/#TenNetLib.SweepData","page":"Sweeping through the MPS","title":"TenNetLib.SweepData","text":"mutable struct SweepData\n    sweepcount::Int\n    maxchi::Vector{Int}\n    energy::Vector{Float64}\n    entropy::Vector{Float64}\n    maxtruncerr::Vector{Float64}\n    lasteigs::Vector{Vector{Float64}}\nend\n\nHolds historical data after each (full)sweep. Requires for convergence check etc.\n\nsweepcount::Int: Number of fullsweeps performed.\nmaxchi::Vector{Int}: Maximum MPS bond/link dimensions after every sweep.\nenergy::Vector{Float64}: Energies after every sweep.\nentropy::Vector{Float64}: Mid-chain entropies after every sweep.\nmaxtrucerr::Vector{Float64}: Maximum truncation error after every sweep.\nlasteigs::Vector{Vector{Float64}}: Spectrum of eigenvalues at each bond after previous halfsweep.\n\nDefault constructor:\n\nSweepData(): Initialize an empty SweepData object.\n\n\n\n\n\n","category":"type"},{"location":"mps/sweep/#Base.copy-Tuple{SweepData}","page":"Sweeping through the MPS","title":"Base.copy","text":"Base.copy(swdata::SweepData)\n\nShallow copy of SweepData.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep/#Perform-a-fullsweep","page":"Sweeping through the MPS","title":"Perform a fullsweep","text":"","category":"section"},{"location":"mps/sweep/#TenNetLib.fullsweep!-Tuple{StateEnvs, Any, Int64, SweepData}","page":"Sweeping through the MPS","title":"TenNetLib.fullsweep!","text":"function fullsweep!(sysenv::StateEnvs, solver, nsite::Int, swdata::SweepData;\n                    kwargs...)\n\nPerform a fullsweep (left-to-right and right-to-left) by solver.\n\nArguments:\n\nsysenv::StateEnvs.\nsolver: Solver for update. Available ones: eig_solver and exp_solver.\nnsite::Int of the environment. Either 1 or 2 for one-site or two-site update  respectively.\nswdata::SweepData.\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for TDVP. \nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nreverse_step::Bool = false if time_step = nothing, true otherwise.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14 if eig_solver, 1E-12 if exp_solver.\nsolver_krylovdim::Int = 5 if eig_solver, 30 if exp_solver.\nsolver_maxiter::Int = 2 if eig_solver, 100 if exp_solver.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false if eig_solver, true if exp_solver.\nsolver_check_convergence::Bool = false if eig_solver, true if exp_solver.\n\nReturn values:\n\n::Float64: Change in Energy ΔE\n::Float64: Change in Entropy ΔS\n\nswdata::SweepData gets updated.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep/#Perform-a-dynamical-fullsweep","page":"Sweeping through the MPS","title":"Perform a dynamical fullsweep","text":"","category":"section"},{"location":"mps/sweep/","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"TenNetLib.jl defines the following function to dynamically decide whether to perform single- or two-site update at each bond, depending on the entropy growth at the previous halfsweep.","category":"page"},{"location":"mps/sweep/#TenNetLib.dynamic_fullsweep!-Tuple{StateEnvs, Any, SweepData}","page":"Sweeping through the MPS","title":"TenNetLib.dynamic_fullsweep!","text":"function dynamic_fullsweep!(sysenv::StateEnvs, solver, swdata::SweepData;\n                            kwargs...)\n\nPerform a dynamic fullsweep (left-to-right and right-to-left) by solver. The very first sweep, as dictated by swdata.sweepcount=0, Global Subspace Expansion (see below) is performed followed by a pure one-site sweep if typeof(sysenv) == StateEnvs{ProjMPO}, else performs a full two-site sweep. At each bond, if the lowest eigenvalue is below eigthreshold or the bond dimension at that bond has reached maxdim at a particular halfsweep, performs single-site update across that bond in the subsequent halfsweep, otherwise performs two-site update.\n\nArguments:\n\nsysenv::StateEnvs.\nsolver: Solver for update. Available ones: eig_solver and exp_solver.\nswdata::SweepData.\n\nNamed arguments and their default values:\n\ntime_step::Union{Float64, ComplexF64, Nothing} = nothing: Time step for TDVP. \nnormalize::Bool = true: Whether to normalize after update.\nmaxdim::Int = typemax(Int): Maximum bond dimension after SVD truncation.\nmindim::Int = 1: Minimum bond dimension after SVD truncation.\ncutoff::Float64 = Float64_threshold(): Cutoff for SVD truncation.\nsvd_alg::String = \"divide_and_conquer\".\nnoise::Float64 = 0.0.\nreverse_step::Bool = false if time_step = nothing, true otherwise.\noutputlevel::Int = 1. If 0 prints no information, for 1 outputs after every fullsweep, if 2 prints at every update step.\neigthreshold::Float64 = 1E-12.\nextendat::Union{Nothing, Int} = nothing: If specified, at every extendatth sweep, Global Subspace Expansion is performed followed by a pure one-site sweep if typeof(sysenv) == StateEnvs{ProjMPO}, else performs a full two-site sweep.\n\nNamed arguments for solver and their default values:\n\nSee the documentation of KrylovKit.jl.\n\nishermitian::Bool = true.\nsolver_tol::Float64 = 1E-14 if eig_solver, 1E-12 if exp_solver.\nsolver_krylovdim::Int = 3 if eig_solver, 30 if exp_solver.\nsolver_maxiter::Int = 1 if eig_solver, 100 if exp_solver.\nsolver_outputlevel::Int = 0: See verbosity in KrylovKit.jl.\nsolver_eager::Bool = false if eig_solver, true if exp_solver.\nsolver_check_convergence::Bool = false if eig_solver, true if exp_solver.\n\nArguments for Global Subspace Expansion and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = 0.0: Cutoff for the application of the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension for the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\nReturn values:\n\n::Float64: Change in Energy ΔE\n::Float64: Change in Entropy ΔS\n\nswdata::SweepData gets updated.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep/#Global-Subspace-Expansion","page":"Sweeping through the MPS","title":"Global Subspace Expansion","text":"","category":"section"},{"location":"mps/sweep/","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"Following Phys. Rev. B 102, 094315 (2020), a Global Subspace Expansion can be performed using Krylov subspace if the environments are created by a single MPO.","category":"page"},{"location":"mps/sweep/#TenNetLib.krylov_extend!-Tuple{MPS, MPO}","page":"Sweeping through the MPS","title":"TenNetLib.krylov_extend!","text":"function krylov_extend!(psi::MPS, H::MPO; kwargs...)\n\nPerforms Global Subspace Expansion.\n\nNamed arguments and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep/#TenNetLib.krylov_extend!-Tuple{StateEnvs{ProjMPO}}","page":"Sweeping through the MPS","title":"TenNetLib.krylov_extend!","text":"function krylov_extend!(sysenv::StateEnvs{ProjMPO}; kwargs...)\n\nPerforms Global Subspace Expansion. The StateEnvs must be created by a single MPO.\n\nNamed arguments and their default values:\n\nextension_krylovdim::Int = 3: Number of Krylov vectors used for GSE.\nextension_applyH_cutoff::Float64 = Float64_threshold(): Cutoff for the application the MPO to the MPS.\nextension_applyH_maxdim::Int = maxlinkdim(psi) + 1: Maximum bond/link dimension of the resulting MPS after the application of the MPO to the MPS.\nextension_cutoff::Float64 = 1E-10: Cutoff for the basis extension step in GSE.\n\n\n\n\n\n","category":"method"},{"location":"mps/sweep/","page":"Sweeping through the MPS","title":"Sweeping through the MPS","text":"info: Info\nApart from TDVP, Global Subspace Expansion is also very useful for DMRG to get rid of nasty local minimas.","category":"page"},{"location":"ttn/measure_ttn/#Measuring-the-TTN","page":"Measuring the TTN","title":"Measuring the TTN","text":"","category":"section"},{"location":"ttn/measure_ttn/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, TTN, ITensor}} where T<:Union{Float64, ComplexF64}","page":"Measuring the TTN","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::TTN, opten::ITensor)\n\nReturns (complex / real) local expectation value (::ComplexF64 / ::Float64) of a given TTN psi::TTN. The operator opten::ITensor must be single-site operator.\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"ttn/measure_ttn/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, TTN, String, Int64}} where T<:Union{Float64, ComplexF64}","page":"Measuring the TTN","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::TTN, opstr::String, pos::Int)\n\nReturns (complex / real) local expectation value (::ComplexF64 / ::Float64) of a given TTN psi::TTN for a given operator name (opstr::String) and a site index (pos::Int) \n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"ttn/measure_ttn/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, TTN, String}} where T<:Union{Float64, ComplexF64}","page":"Measuring the TTN","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::TTN, opstr::String; kwargs...)\n\nReturns (complex / real) local expectation values (::Vector{ComplexF64} / ::Vector{Float64}) of a given TTN psi::TTN for a given operator name (opstr::String) at all the sites.\n\nOptionally, for specific sites, keyword argument sites can be specified, e.g., sites = [1, 2, 3].\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"ttn/measure_ttn/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, TTN, Vector{ITensor}}} where T<:Union{Float64, ComplexF64}","page":"Measuring the TTN","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::TTN, optens::Vector{ITensor})\n\nReturns (complex / real) multi-site expectation value (::ComplexF64 / ::Float64) of a given TTN psi::TTN for a given vector of single-site operators (optens::Vector{ITensor}).\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\n\n\n\n\n","category":"method"},{"location":"ttn/measure_ttn/#TenNetLib.measure-Union{Tuple{T}, Tuple{Type{T}, TTN, Vector{Pair{String, Int64}}}} where T<:Union{Float64, ComplexF64}","page":"Measuring the TTN","title":"TenNetLib.measure","text":"function measure(::Type{ElT} = ComplexF64, psi::TTN, oppairs::Vector{Pair{String, Int}};\n                 isfermions::Bool = true)\n\nReturns (complex / real) multi-site expectation value (::ComplexF64 / ::Float64) of a given TTN psi::TTN. oppairs::Vector{Pair{String, Int}} contains pairs of operator names (String) and site locations (Int). E.g., for <ψ|OᵢOⱼOₖ... |ψ>, oppairs = [\"O\" => i, \"O\" => j, \"O\" => k,...].\n\nFermionic JW strings are added automatically for fermionic operators if isfermions::Bool = true (default).\n\nFor ElT = Float64, if the expectation value is complex, raises a warning!\n\nExample:\n\nvalueC = measure(psi, [\"Cdag\" => 2, \"C\" => 6, \"Cdag\" => 9, \"C\" => 12])\nvalueR = measure(Float64, psi, [\"Cdag\" => 2, \"C\" => 6, \"Cdag\" => 9, \"C\" => 12])\n\n\n\n\n\n","category":"method"},{"location":"base/fermions/#Dealing-with-Fermions","page":"Dealing with Fermions","title":"Dealing with Fermions","text":"","category":"section"},{"location":"base/fermions/","page":"Dealing with Fermions","title":"Dealing with Fermions","text":"TenNetLib.jl uses the following function to teat fermionic operators.","category":"page"},{"location":"base/fermions/#TenNetLib.bosonize-Union{Tuple{T}, Tuple{Vector{Pair{String, Int64}}, Array{Index{T}, 1}}} where T","page":"Dealing with Fermions","title":"TenNetLib.bosonize","text":"function bosonize(oppair::Vector{Pair{String, Int}},\n                  sites::Vector{Index})\n\nGiven a string of operator names with positions in the form of Vector{Pair{String, Int}} \"bosonizes\" the operator string by putting the Jordan-Wigner string \"F\" at appropriate places.\n\nArguments\n\noppair::Vector{Pair{String, Int}}: Input string of operator names with positions.\nsites::Vector{Index}: The entire site Indexs as per ITensors' convention.\n\nReturn values\n\n::Int: Even (+1) or odd (-1) permutation.\n::Vector{Pair{String, Int}}:  modified string of operator names and positions.\n\n\n\n\n\n","category":"method"},{"location":"#TenNetLib.jl","page":"Introduction","title":"TenNetLib.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Tensor Network Library (TenNetLib.jl) built on top of ITensors.jl and ITensorMPS.jl for quantum many-body problems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Build Status Documentation\n(Image: Build Status) (Image: Build Status)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code for TenNetLib.jl can be found on GitHub.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation for TenNetLib.jl can be found here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This library requires Julia 1.10+.","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TenNetLib.jl features widely-used Tensor Network (TN) codes, designed with a multi-layered abstraction to cater to diverse user needs. The library provides users with varying levels of control over their computations. Currently, TenNetLib.jl presents an array of functionalities for:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(a) Finite-size Matrix-Product States (MPS): Different variants of Density Matrix Renormalization Group (DMRG) and Time Dependent Variational Principle (TDVP) (including subspace expansion) methods.\n(b) Tree Tensor Network (TTN): Variational search for the ground state and first few excited states.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TenNetLib.jl is registered on Julia General Registry. To install the library (along with ITensors.jl), you can use the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ julia\n\njulia> ]\n\npkg> add ITensors\n\npkg> add ITensorMPS\n\npkg> add TenNetLib","category":"page"},{"location":"#Found-an-issue-or-bug?","page":"Introduction","title":"Found an issue or bug?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"\"Beware of bugs in the above code; I have only proved it correct, not tried it.\"    – Donald Knuth","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you find bugs or mistakes of any kind, please let us know by adding an issue to the GitHub issue tracker. You are also welcome to submit a pull request.","category":"page"},{"location":"#Future-functionality?","page":"Introduction","title":"Future functionality?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is a list for future additions in the decreasing order of priority. Any help / suggestion is welcome.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Augmented Tree Tensor Network (aTTN) for variational ground state search for 2D problems.\nInfinite DMRG (iDMRG) and/or Variational Uniform Matrix Product States (VUMPS) to tackle 1D / quasi-1D problems directly at the thermodynamic limit.\nProjected Entangled Pair States (PEPS) for 2D problems.\nReal-time evolution method using PEPS and TTN.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Also, please feel free to ask about a new feature by adding a new request to the GitHub issue tracker labelled feature request. Note that submitting a pull request, providing the needed changes to introduced your requested feature, will speed up the process.","category":"page"},{"location":"#Example:-A-simple-DMRG-code","page":"Introduction","title":"Example: A simple DMRG code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following code is for a simple DMRG run at the highest level of abstraction without any additional control.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ITensors\nusing ITensorMPS\nusing TenNetLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpSum()\n    \n    for j=1:N-1\n        os += 1, \"Sz\", j,\"Sz\", j+1\n        os += 0.5, \"S+\", j, \"S-\", j+1\n        os += 0.5, \"S-\", j, \"S+\", j+1\n    end\n    \n    H = MPO(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    params = DMRGParams(;nsweeps = [5, 5], maxdim = [20, 50],\n                        cutoff = 1e-14, noise = 1e-3, noisedecay = 2,\n                        disable_noise_after = 3)\n\n    # dmrg2 for two-site DMRG\n    en, psi = dmrg2(psi0, H, params)\nend","category":"page"},{"location":"#Example:-A-simple-TDVP-code","page":"Introduction","title":"Example: A simple TDVP code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following code is for a simple TDVP run at the highest level of abstraction without any additional control.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ITensors\nusing ITensorMPS\nusing TenNetLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpSum()\n    \n    for j=1:N-1\n        os += 1, \"Sz\", j,\"Sz\", j+1\n        os += 0.5, \"S+\", j, \"S-\", j+1\n        os += 0.5, \"S-\", j, \"S+\", j+1\n    end\n    \n    H = MPO(os,sites)\n    states = [isodd(n) ? \"Up\" : \"Dn\" for n in 1:N]\n    psi0 = MPS(sites, states)\n\n    tau = -0.01im    \n    engine = TDVPEngine(psi0, H)\n    for ii = 1:100\n\n    \t# `nsite = \"dynamic\"` for dynamical selection between\n\t# single- and two-site variants at different bonds\n        tdvpsweep!(engine, tau,\n                   nsite = \"dynamic\";\n                   maxdim = 200,\n                   cutoff = 1E-12,\n                   extendat = 5)\n\n\tpsi = getpsi(engine)\n\t# DO STUFF\n    end\nend","category":"page"},{"location":"#Example:-A-simple-TTN-ground-state-optimzation-code","page":"Introduction","title":"Example: A simple TTN ground-state optimzation code","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following code is for a simple TTN ground-state optimzation run at the highest level of abstraction without any additional control. Here we use OpStrings and CouplingModel instead of OpSum and MPO.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ITensors\nusing ITensorMPS\nusing TenNetLib\n\nlet\n    N = 32\n    sites = siteinds(\"S=1/2\",N)\n    os = OpStrings()\n    \n    for j=1:N-1\n        os += 1, \"Sz\" => j,\"Sz\" => j+1\n        os += 0.5, \"S+\" => j, \"S-\" => j+1\n        os += 0.5, \"S-\"=> j, \"S+\" => j+1\n    end\n    \n    H = CouplingModel(os,sites)\n    psi0 = default_randomTTN(sites, 64, QN(\"Sz\", 0))\n\n    sweeppath = default_sweeppath(psi0)\n    \n    params = OptimizeParamsTTN(; maxdim = [64, 128], nsweeps = [5, 10], \n                               cutoff = 1e-14, noise = 1e-2, noisedecay = 5, \n                               disable_noise_after = 5)\n\t\t\t       \n    en, psi = optimize(psi0, H, params, sweeppath)\nend","category":"page"}]
}
